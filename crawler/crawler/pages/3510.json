{'html': b'<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">\n<HTML>\n<HEAD>\n'
         b'    <!-- SGI_COMMENT COSMOCREATE -->\n    <!-- SGI_COMMENT VERSIO'
         b'N NUMBER="1.0.2" -->\n    <TITLE>Querying Points on a Hemisphere<'
         b'/TITLE>\n</HEAD>\n<BODY>\n<H1>\nConstant Time Queries on Uniformly D'
         b'istributed Points on a Hemisphere</H1>\n<P>\n<A HREF="http://www.c'
         b's.ucl.ac.uk/staff/m.slater">Mel Slater</A></P>\n<H2>\nSoftware</H2'
         b'>\n<P>\nThere is an illustrative implemention of the algorithm des'
         b'cribed in the \npaper. It has been developed and tested on a SGI '
         b'O2 MIPS R5000, Rev 2. \nIt has also been executed on a Toshiba Po'
         b'rtege 7200 Series laptop with <A\n HREF="http://www.msdn.microsof'
         b't.com">Microsoft Visual C++ 6.0</A> - on \nwhich it still works, '
         b'but there are more reported errors. This is \nprobably to do with'
         b' differences in floating point precision between the \ntwo machin'
         b'es.</P>\n<P>\nThe implementation makes use of <A\n HREF="http://rea'
         b'lity.sgi.com/opengl/">OpenGL</A> and the <A\n HREF="http://realit'
         b'y.sgi.com/opengl/glut3/glut3.html">GLUT</A>\n library. It also ma'
         b'kes use of a 3D graphics library developed for \nteaching, which '
         b'for convenience provides some basic data structures \nsuch as Poi'
         b'nt3D, and also a camera model. There is <A\n HREF="http://www.cs.'
         b'ucl.ac.uk/staff/m.slater/Teaching/Lib3D">some \ndocumentation </A'
         b'>for this library, though only very few of its data \nstructures '
         b'and functions are used here, and they should be obvious.</P>\n<P>'
         b'\nThe main program, uniform sphere and query point implementation'
         b' are in \nQuerySphere and the graphics library is in Lib3D.</P>\n<'
         b'P>\nThe query sphere implementation writes polygons with RGB floa'
         b'ting point \nvalues into the frame buffer and then reads them out'
         b' using \nglReadPixels. The implementation relies obviously on exa'
         b'ctly the same \nfloating RGB point values being extracted from th'
         b'e framebuffer as went \ninto it.<BR>\nThe implementation assumes t'
         b'hat the floating point values that can be \nrepresented are unifo'
         b'rmly distributed in the space available in the \nnumber of bits f'
         b'or each of the colours. For example, on the Toshiba \nPortege, a '
         b'glGetIntegerv on GL_RED_BITS delivers 5 as the number of \nbits f'
         b'or red. It is assumed that floating point values available for \n'
         b'red between 0.0 and 1.0 are therefore i/31.0 (i=0,1,...,31) on this '
         b'\nmachine. This type of calculation gives correct results on both'
         b' the SGI\nand the Portege. Note that OpenGL does transform the da'
         b'ta stored in the \nframebuffer in various ways (eg, see the docum'
         b'entation for \nglReadPixels) so that it is important to check thi'
         b's.</P>\n<P>\nAnother simple program (colortest) simply fills a win'
         b'dow with a color \nwith speficied RGB values decoded from an arbi'
         b'trary integer and then \nreads back the framebuffer and prints ou'
         b't the RGB values obtained and \nthe reconstruction of the integer'
         b' code. If this program does not work \nthen nor will the query sp'
         b'here program.</P>\n<P>\n<A HREF="QuerySphere.tar.gz">QuerySphere.t'
         b'ar.gz</A></P>\n<P>\n<A HREF="Lib3D.tar.gz">Lib3D.tar.gz</A></P>\n<P'
         b'>\n</P>\n</BODY>\n</HTML>\n',
 'links': [2970, 3511, 3512, 3513],
 'pid': 3510,
 'url': 'http://www0.cs.ucl.ac.uk/staff/M.Slater/Papers/Sphere/Code/'}