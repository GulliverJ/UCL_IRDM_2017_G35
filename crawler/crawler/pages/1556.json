{'html': b'(*\n The Isabelle/HOL proof script accompanying the paper\n "The L'
         b'aws of Programming Unify Process Calculi"\n*)\n\ntheory LawsOfProgr'
         b'ammingUnifyProcessCalculi\n  imports Main\nbegin\n\ndeclare [[ smt_s'
         b'olver = remote_z3]]\ndeclare [[ smt_timeout = 60 ]]\ndeclare [[ z3'
         b'_options = "-memory:500" ]]\n\nsection {* The basic algebra *}\n\nlo'
         b'cale basicalgebra =\n  fixes refinement :: "\'a \\<Rightarrow> '
         b'\'a \\<Rightarrow> bool" (infix "\\<sqsubseteq>" 50)\n  and disjunct'
         b'ion :: "\'a \\<Rightarrow> \'a \\<Rightarrow> \'a" (infixl "\\<squ'
         b'nion>" 65)\n  and conjunction :: "\'a \\<Rightarrow> \'a \\<Right'
         b'arrow> \'a" (infixl "\\<sqinter>" 70)\n  and semicolon :: "\'a \\'
         b'<Rightarrow> \'a \\<Rightarrow> \'a" (infixl ";" 80)\n  and concurre'
         b'ncy :: "\'a \\<Rightarrow> \'a \\<Rightarrow> \'a" (infixl "\\<par'
         b'allel>" 80)\n  and bottom :: "\'a" ("\\<bottom>")\n  and top :: '
         b'"\'a" ("\\<top>")\n  and skip :: "\'a"\n  and iteration :: "\'a \\<'
         b'Rightarrow> \'a" ("_\\<^sup>\\<star>" [101] 100)\n  assumes refineme'
         b'nt_reflexive: "x\\<sqsubseteq>x"\n  and refinement_transitive: "x\\'
         b'<sqsubseteq>y \\<Longrightarrow> y\\<sqsubseteq>z \\<Longrightarrow'
         b'> x\\<sqsubseteq>z"\n  and refinement_antisymmetric: "x\\<sqsubsete'
         b'q>y \\<Longrightarrow> y\\<sqsubseteq>x \\<Longrightarrow> x=y"\n  a'
         b'nd disj_increasing1: "x \\<sqsubseteq> x\\<squnion>y"\n  and disj_i'
         b'ncreasing2: "y \\<sqsubseteq> x\\<squnion>y"\n  and disj_lub: "x\\<s'
         b'qsubseteq>z \\<Longrightarrow> y\\<sqsubseteq>z \\<Longrightarrow> '
         b'x\\<squnion>y \\<sqsubseteq> z"\n  and conj_decreasing1: "x\\<sqinte'
         b'r>y \\<sqsubseteq> x"\n  and conj_decreasing2: "x\\<sqinter>y \\<sqs'
         b'ubseteq> y"\n  and conj_glb: "x \\<sqsubseteq> y \\<Longrightarrow>'
         b' x \\<sqsubseteq> z \\<Longrightarrow> x \\<sqsubseteq> y\\<sqinter>'
         b'z"\n  (* The table *)\n  assumes disjunction_commutative: "x\\<squn'
         b'ion>y = y\\<squnion>x"\n  and disjunction_associative: "x\\<squnion'
         b'>(y\\<squnion>z) = (x\\<squnion>y)\\<squnion>z"\n  and disjunction_i'
         b'dempotent: "x\\<squnion>x = x"\n  and disjunction_left_unit: "\\<bo'
         b'ttom>\\<squnion>x = x"\n  and disjunction_right_unit: "x\\<squnion>'
         b'\\<bottom> = x"\n  and disjunction_left_zero: "\\<top>\\<squnion>x ='
         b' \\<top>"\n  and disjunction_right_zero: "x\\<squnion>\\<top> = '
         b'\\<top>"\n  and conjunction_commutative: "x\\<sqinter>y = y\\<sqinte'
         b'r>x"\n  and conjunction_associative: "x\\<sqinter>(y\\<sqinter>z) ='
         b' (x\\<sqinter>y)\\<sqinter>z"\n  and conjunction_idempotent: "x\\<sq'
         b'inter>x = x"\n  and conjunction_left_unit: "\\<top>\\<sqinter>x = x'
         b'"\n  and conjunction_right_unit: "x\\<sqinter>\\<top> = x"\n  and co'
         b'njunction_left_zero: "\\<bottom>\\<sqinter>x = \\<bottom>"\n  and co'
         b'njunction_right_zero: "x\\<sqinter>\\<bottom> = \\<bottom>"\n  and s'
         b'emicolon_associative: "x;(y;z) = (x;y);z"\n  and semicolon_left_u'
         b'nit: "skip;x = x"\n  and semicolon_right_unit: "x;skip = x"\n  and'
         b' semicolon_left_zero: "\\<bottom>;x = \\<bottom>"\n  and semicolon_'
         b'right_zero: "x;\\<bottom> = \\<bottom>"\n  and concurrency_commutat'
         b'ive: "x\\<parallel>y = y\\<parallel>x"\n  and concurrency_associati'
         b've: "x\\<parallel>(y\\<parallel>z) = (x\\<parallel>y)\\<parallel'
         b'>z"\n  and concurrency_left_unit: "skip\\<parallel>x = x"\n  and co'
         b'ncurrency_right_unit: "x\\<parallel>skip = x"\n  and concurrency_l'
         b'eft_zero: "\\<bottom>\\<parallel>x = \\<bottom>"\n  and concurrency_'
         b'right_zero: "x\\<parallel>\\<bottom> = \\<bottom>"\n  (* Distributio'
         b'n laws *)\n  fixes distr_through_disj_p :: "(\'a \\<Rightarrow> \'a '
         b'\\<Rightarrow> \'a) \\<Rightarrow> bool" \n  defines "distr_through_'
         b'disj_p f \\<equiv> (\\<forall> x y z . (f x (y\\<squnion>z) = (f x '
         b'y) \\<squnion> (f x z)) \\<and> (f (x\\<squnion>y) z) = ((f x z) \\<'
         b'squnion> (f y z)))"\n  assumes disj_distr_through_disj: "distr_th'
         b'rough_disj_p (op \\<squnion>)"\n  and conj_distr_through_disj: "di'
         b'str_through_disj_p (op \\<sqinter>)"\n  and semicolon_distr_throug'
         b'h_disj: "distr_through_disj_p (op ;)"\n  and concurrency_distr_th'
         b'rough_disj: "distr_through_disj_p (op \\<parallel>)"\n  and exchan'
         b'ge: "(p\\<parallel>q);(r\\<parallel>s) \\<sqsubseteq> (p;r)\\<parall'
         b'el>(q;s)"\n  (* Kleene star laws *)\n  assumes iter1: "skip \\<squn'
         b'ion> (p;p\\<^sup>\\<star>) \\<sqsubseteq> p\\<^sup>\\<star>"\n  an'
         b'd iter2: "p \\<squnion> (q;r) \\<sqsubseteq> r \\<Longrightarrow> q'
         b'\\<^sup>\\<star>;p \\<sqsubseteq> r"\n  and iter3: "skip \\<squni'
         b'on> (p\\<^sup>\\<star>;p) \\<sqsubseteq> p\\<^sup>\\<star>"\n  and'
         b' iter4: "p \\<squnion> (r;q) \\<sqsubseteq> r \\<Longrightarrow> p;'
         b'q\\<^sup>\\<star> \\<sqsubseteq> r"\n(* Auxiliary definitions. They '
         b'appear here because otherwise the sublocale handling will raise prob'
         b'lems later. *)\n  fixes lessthan :: "\'a \\<Rightarrow> \'a \\<Ri'
         b'ghtarrow> bool"   (infix "\\<sqsubset>" 50)\n  defines "x\\<sqsubse'
         b't>y \\<equiv> (x\\<sqsubseteq>y) \\<and> \\<not>(y\\<sqsubseteq>x'
         b')"\n  fixes monotone_p :: "(\'a \\<Rightarrow> \'a \\<Rightarrow>'
         b' \'a) \\<Rightarrow> bool" \n  defines "monotone_p f \\<equiv> ('
         b'\\<forall> x y z . (x \\<sqsubseteq> y \\<longrightarrow> (f x z) \\'
         b'<sqsubseteq> (f y z))) \\<and> (\\<forall> x y z . (y \\<sqsubseteq'
         b'> z \\<longrightarrow> (f x y) \\<sqsubseteq> (f x z)))"\n  (* Don\''
         b't define backsemicolon x y \\<equiv> y;x explicitly - it will mak'
         b'e automation difficult. *)\nbegin\n\ntext {* Simple consequences of'
         b' the laws. *}\nlemma conj_disj_relationship: "q=p\\<squnion>q \\<lo'
         b'ngleftrightarrow> p=p\\<sqinter>q"\n  by (metis conj_decreasing1 c'
         b'onj_decreasing2 conj_glb disj_increasing1 disj_increasing2 disj_lub '
         b'refinement_antisymmetric refinement_reflexive)\n\nlemma refinement'
         b'_disj: "x\\<sqsubseteq>y \\<longleftrightarrow> y=x\\<squnion>y"\n  '
         b'by (metis disj_increasing1 disj_increasing2 disj_lub refinement_anti'
         b'symmetric refinement_reflexive)\nlemma refinement_conj: "x\\<sqsub'
         b'seteq>y \\<longleftrightarrow> x=x\\<sqinter>y"\n  by (metis conj_d'
         b'ecreasing2 conj_disj_relationship refinement_disj)\n\nlemma bottom'
         b'_least: "\\<bottom>\\<sqsubseteq>x"\n  by (metis disj_increasing2 d'
         b'isjunction_right_unit)\nlemma top_greatest: "x\\<sqsubseteq>\\<top>'
         b'"\n  by (metis conj_decreasing1 conjunction_left_unit)\n\nlemma ite'
         b'r_unfold1: "skip \\<sqsubseteq> p\\<^sup>\\<star>"\n  by (metis disj'
         b'_increasing1 iter1 refinement_transitive)\nlemma iter_unfold2: "p'
         b';p\\<^sup>\\<star> \\<sqsubseteq> p\\<^sup>\\<star>"\n  by (metis '
         b'disj_increasing2 iter1 refinement_transitive)\n\ntext {* Any opera'
         b'tor that distributes through disjunction is monotone. *}\nlemma d'
         b'istr_through_disj_implies_monotone: "distr_through_disj_p f \\<Lo'
         b'ngrightarrow> monotone_p f"\n  by (metis (full_types) distr_throu'
         b'gh_disj_p_def monotone_p_def refinement_disj)\n\ntext {* The binar'
         b'y operators are therefore monotone. *}\nlemma disj_monotone: "mon'
         b'otone_p (op \\<squnion>)"\n  by (metis disj_distr_through_disj dis'
         b'tr_through_disj_implies_monotone)\nlemma conj_monotone: "monotone'
         b'_p (op \\<sqinter>)"\n  by (metis conj_distr_through_disj distr_th'
         b'rough_disj_implies_monotone)\nlemma semicolon_monotone: "monotone'
         b'_p (op ;)"\n  by (metis semicolon_distr_through_disj distr_throug'
         b'h_disj_implies_monotone)\nlemma concurrency_monotone: "monotone_p'
         b' (op \\<parallel>)"\n  by (metis concurrency_distr_through_disj di'
         b'str_through_disj_implies_monotone)\n\ntext {* Lemmas that aid auto'
         b'mation. *}\nlemma disj_monotone1: "x \\<sqsubseteq> y \\<Longrighta'
         b'rrow> x\\<squnion>z \\<sqsubseteq> y\\<squnion>z"\n  by (metis monot'
         b'one_p_def disj_monotone)\nlemma conj_monotone1: "x \\<sqsubseteq> '
         b'y \\<Longrightarrow> x\\<sqinter>z \\<sqsubseteq> y\\<sqinter>z"'
         b'\n  by (metis monotone_p_def conj_monotone)\nlemma semicolon_monot'
         b'one1: "x \\<sqsubseteq> y \\<Longrightarrow> x;z \\<sqsubseteq> y;z'
         b'"\n  by (metis monotone_p_def semicolon_monotone)\nlemma concurren'
         b'cy_monotone1: "x \\<sqsubseteq> y \\<Longrightarrow> x\\<parallel>z'
         b' \\<sqsubseteq> y\\<parallel>z"\n  by (metis monotone_p_def concurr'
         b'ency_monotone)\nlemma disj_monotone2: "y \\<sqsubseteq> z \\<Longri'
         b'ghtarrow> x\\<squnion>y \\<sqsubseteq> x\\<squnion>z"\n  by (metis m'
         b'onotone_p_def disj_monotone)\nlemma conj_monotone2: "y \\<sqsubset'
         b'eq> z \\<Longrightarrow> x\\<sqinter>y \\<sqsubseteq> x\\<sqinter>z"'
         b'\n  by (metis monotone_p_def conj_monotone)\nlemma semicolon_monot'
         b'one2: "y \\<sqsubseteq> z \\<Longrightarrow> x;y \\<sqsubseteq> x;z'
         b'"\n  by (metis monotone_p_def semicolon_monotone)\nlemma concurren'
         b'cy_monotone2: "y \\<sqsubseteq> z \\<Longrightarrow> x\\<parallel>y'
         b' \\<sqsubseteq> x\\<parallel>z"\n  by (metis monotone_p_def concurr'
         b'ency_monotone)\n\ntext {* The small exchange laws hold. *}\nlemma s'
         b'mall_exchange1: "x;(y\\<parallel>z) \\<sqsubseteq> (x;y)\\<parallel'
         b'>z"\n  by (metis concurrency_right_unit exchange semicolon_left_u'
         b'nit)\nlemma small_exchange2: "(x\\<parallel>y);z \\<sqsubseteq> x\\<'
         b'parallel>(y;z)"\n  by (metis concurrency_left_unit exchange semic'
         b'olon_right_unit)\n\ntext {* Sequential composition is a special ca'
         b'se of concurrent composition *}\nlemma seq_refines_conc: "x;y \\<s'
         b'qsubseteq> x\\<parallel>y"\n  by (metis concurrency_right_unit sem'
         b'icolon_left_unit small_exchange2)\n\ntext {* Any monotone operator'
         b' exchanges with conjunction. *}\nlemma monotone_op_exchanges_with'
         b'_conj: "monotone_p f \\<Longrightarrow> f (w \\<sqinter> x) (y \\<s'
         b'qinter> z) \\<sqsubseteq> (f w y)\\<sqinter>(f x z)"\nproof -\n  ass'
         b'ume ap: "monotone_p f"\n  have a: "f (w \\<sqinter> x) (y \\<sqinte'
         b'r> z) \\<sqsubseteq> f w y" by (metis monotone_p_def ap conj_decr'
         b'easing1 refinement_transitive)\n  have b: "f (w \\<sqinter> x) (y '
         b'\\<sqinter> z) \\<sqsubseteq> f x z" by (metis monotone_p_def ap c'
         b'onjunction_commutative conj_decreasing1 refinement_transitive)\n '
         b' from a b show ?thesis by (metis conj_disj_relationship conjunction_'
         b'associative refinement_disj)\nqed\ntext {* In particular, sequenti'
         b'al composition exchanges with conjunction. *}\nlemma conjunction_'
         b'exchange: "(w\\<sqinter>x);(y\\<sqinter>z) \\<sqsubseteq> (w;y)\\<sq'
         b'inter>(x;z)"\n  by (metis monotone_op_exchanges_with_conj semicol'
         b'on_monotone)\n\ntext {* The dual property says that a monotone ope'
         b'rator reverse-exchanges with disjunction. *}\nlemma monotone_op_r'
         b'everse_exchanges_with_disj: "monotone_p f \\<Longrightarrow> (f w'
         b' y)\\<squnion>(f x z) \\<sqsubseteq> f (w \\<squnion> x) (y \\<squni'
         b'on> z)"\nproof -\n  assume ap: "monotone_p f"\n  have a: " f w y \\<'
         b'sqsubseteq> f (w \\<squnion> x) (y \\<squnion> z)" by (metis monot'
         b'one_p_def ap disj_increasing1 refinement_transitive)\n  have b: "'
         b'f x z \\<sqsubseteq> f (w \\<squnion> x) (y \\<squnion> z)" by (met'
         b'is monotone_p_def ap disjunction_commutative disj_increasing1 refine'
         b'ment_transitive)\n  from a b show ?thesis by (metis disjunction_a'
         b'ssociative refinement_disj)\nqed\n\ntext {* Time reversal duality ('
         b'opposition). *}\nlemma time_reversal: "basicalgebra (op \\<sqsubse'
         b'teq>) (op \\<squnion>) (op \\<sqinter>) (\\<lambda> x y . y;x) (op '
         b'\\<parallel>) \\<bottom> \\<top> skip iteration"\napply (rule basica'
         b'lgebra.intro)\napply (rule refinement_reflexive)\napply (metis ref'
         b'inement_transitive)\napply (metis refinement_antisymmetric)\napply'
         b' (rule disj_increasing1)\napply (rule disj_increasing2)\napply (me'
         b'tis disj_lub)\napply (rule conj_decreasing1)\napply (rule conj_dec'
         b'reasing2)\napply (metis conj_glb)\napply (metis disjunction_commut'
         b'ative)\napply (metis disjunction_associative)\napply (metis disjun'
         b'ction_idempotent)\napply (metis disjunction_left_unit)\napply (met'
         b'is disjunction_right_unit)\napply (metis disjunction_left_zero)\na'
         b'pply (metis disjunction_right_zero)\napply (metis conjunction_com'
         b'mutative)\napply (metis conjunction_associative)\napply (metis con'
         b'junction_idempotent)\napply (metis conjunction_left_unit)\napply ('
         b'metis conjunction_right_unit)\napply (metis conjunction_left_zero'
         b')\napply (metis conjunction_right_zero)\napply (metis semicolon_as'
         b'sociative)\napply (metis semicolon_right_unit)\napply (metis semic'
         b'olon_left_unit)\napply (metis semicolon_right_zero)\napply (metis '
         b'semicolon_left_zero)\napply (metis concurrency_commutative)\napply'
         b' (metis concurrency_associative)\napply (metis concurrency_left_u'
         b'nit)\napply (metis concurrency_right_unit)\napply (metis concurren'
         b'cy_left_zero)\napply (metis concurrency_right_zero)\napply (metis '
         b'disj_distr_through_disj distr_through_disj_p_def)\napply (metis c'
         b'onj_distr_through_disj distr_through_disj_p_def)\napply (metis se'
         b'micolon_distr_through_disj distr_through_disj_p_def)\napply (meti'
         b's concurrency_distr_through_disj distr_through_disj_p_def)\napply'
         b' (metis exchange)\napply (metis iter3)\napply (metis iter4)\napply '
         b'(metis iter1)\nby (metis iter2)\n\ntext {* Familiar algebraic struc'
         b'tures. *}\nlemma is_partial_order: "class.order (op \\<sqsubseteq>'
         b') (op \\<sqsubset>)"\napply (rule class.order.intro)\napply (rule c'
         b'lass.preorder.intro)\napply (metis lessthan_def)\napply (metis ref'
         b'inement_reflexive)\napply (metis refinement_transitive)\napply (ru'
         b'le class.order_axioms.intro)\napply (metis refinement_antisymmetr'
         b'ic)\ndone\n\nlemma is_lattice: "class.lattice (op \\<sqinter>) ('
         b'op \\<sqsubseteq>) (op \\<sqsubset>) (op \\<squnion>)"\napply (rule '
         b'class.lattice.intro)\napply (rule class.semilattice_inf.intro)\nap'
         b'ply (rule is_partial_order)\napply (rule class.semilattice_inf_ax'
         b'ioms.intro)\napply (metis conj_decreasing1)\napply (metis conj_dec'
         b'reasing1 conjunction_commutative)\napply (metis conj_glb)\napply ('
         b'rule class.semilattice_sup.intro)\napply (rule is_partial_order)\n'
         b'apply (rule class.semilattice_sup_axioms.intro)\napply (metis dis'
         b'j_increasing1)\napply (metis disj_increasing1 disjunction_commuta'
         b'tive)\nby (metis disj_lub)\n\nlemma is_bounded_lattice: "class.boun'
         b'ded_lattice (op \\<sqinter>) (op \\<sqsubseteq>) (op \\<sqsubset>) '
         b'(op \\<squnion>) \\<bottom> \\<top>"\napply (rule class.bounded_latt'
         b'ice.intro)\napply (rule class.bounded_lattice_bot.intro)\napply (r'
         b'ule is_lattice)\napply (rule class.bot.intro)\napply (rule is_part'
         b'ial_order)\napply (rule class.bot_axioms.intro)\napply (rule botto'
         b'm_least)\napply (rule class.bounded_lattice_top.intro)\napply (rul'
         b'e is_lattice)\napply (rule class.top.intro)\napply (rule is_partia'
         b'l_order)\napply (rule class.top_axioms.intro)\nby (metis disjuncti'
         b'on_right_zero refinement_disj)\n\nend\n\n\ntext {* Make the time '
         b'reversed versions of the theorems available. *}\nsublocale basica'
         b'lgebra < time_reverse!: basicalgebra "(op \\<sqsubseteq>)" "(op \\'
         b'<squnion>)" "(op \\<sqinter>)" "(\\<lambda> x y . y;x)" "(op \\<par'
         b'allel>)" "\\<bottom>" "\\<top>" "skip" "iteration"\napply (rule tim'
         b'e_reversal)\napply (rule distr_through_disj_p_def)\napply (rule le'
         b'ssthan_def)\nby (rule monotone_p_def)\n\n\nsection {* Hoare logic *}'
         b'\nlocale hoarelogic = basicalgebra\nbegin\n\nabbreviation (input'
         b') \n  hoare_triple :: "\'a \\<Rightarrow> \'a \\<Rightarrow> \'a \\'
         b'<Rightarrow> bool" ("_\\<lbrace>_\\<rbrace>_" [54,54,54] 53)\n  whe'
         b're "p\\<lbrace>q\\<rbrace>r \\<equiv> p;q \\<sqsubseteq> r"\n\nthe'
         b'orem Hskip: "p\\<lbrace>skip\\<rbrace>p"\n  by (metis refinement_re'
         b'flexive semicolon_right_unit)\ntheorem Hseq: "p\\<lbrace>q\\<rbrace'
         b">r \\<Longrightarrow> r\\<lbrace>q'\\<rbrace>s \\<Longrightarrow"
         b'> p\\<lbrace>q;q\'\\<rbrace>s"\n  by (metis refinement_transitive se'
         b'micolon_associative semicolon_monotone1)\ntheorem Hchoice: "p\\<lb'
         b"race>q\\<rbrace>r \\<Longrightarrow> p\\<lbrace>q'\\<rbrace>r \\<"
         b'Longrightarrow> p\\<lbrace>q\\<squnion>q\'\\<rbrace>r"\n  by (met'
         b'is disj_lub distr_through_disj_p_def semicolon_distr_through_dis'
         b'j)\ntheorem Hconj\': "p\\<lbrace>q\\<rbrace>r \\<Longrightarrow> '
         b"p'\\<lbrace>q'\\<rbrace>r' \\<Longrightarrow> p\\<sqinter>p'\\<lb"
         b'race>q\\<sqinter>q\'\\<rbrace>r\\<sqinter>r\'"\n  by (metis conj_d'
         b'ecreasing1 conj_decreasing2 conj_glb conjunction_exchange refinement'
         b'_transitive)\ntheorem Hiter: "p\\<lbrace>q\\<rbrace>p \\<Longrightar'
         b'row> p\\<lbrace>q\\<^sup>\\<star>\\<rbrace>p"\n  by (metis disjun'
         b'ction_commutative iter4 refinement_disj refinement_reflexive)\nth'
         b'eorem Hcons: "p\'\\<sqsubseteq>p \\<Longrightarrow> p\\<lbrace>q'
         b"\\<rbrace>r \\<Longrightarrow> r\\<sqsubseteq>r' \\<Longrightarrow> "
         b'p\'\\<lbrace>q\\<rbrace>r\'"\n  by (metis refinement_transitive s'
         b'emicolon_monotone1)\ntheorem Hconj: "p\\<lbrace>q\\<rbrace>r \\<Long'
         b"rightarrow> p'\\<lbrace>q\\<rbrace>r' \\<Longrightarrow> p\\<sqinter"
         b'>p\'\\<lbrace>q\\<rbrace>r\\<sqinter>r\'"\n  by (metis Hconj\' conj'
         b'unction_idempotent)\ntheorem Hdisj: "p\\<lbrace>q\\<rbrace>r \\<Long'
         b"rightarrow> p'\\<lbrace>q\\<rbrace>r' \\<Longrightarrow> p\\<squnion"
         b'>p\'\\<lbrace>q\\<rbrace>r\\<squnion>r\'"\n  by (smt disjunction_a'
         b'ssociative disjunction_commutative distr_through_disj_p_def refineme'
         b'nt_disj semicolon_distr_through_disj)\ntheorem Hconc: "p\\<lbrace>'
         b"q\\<rbrace>r \\<Longrightarrow> p'\\<lbrace>q'\\<rbrace>r' \\<Lon"
         b"grightarrow> p\\<parallel>p'\\<lbrace>q\\<parallel>q'\\<rbrace>r"
         b'\\<parallel>r\'"\n  by (metis concurrency_monotone2 concurrency_mon'
         b'otone1 refinement_transitive exchange)\ntheorem Hframe: "p\\<lbrac'
         b'e>q\\<rbrace>r \\<Longrightarrow> f\\<parallel>p\\<lbrace>q\\<rbr'
         b'ace>f\\<parallel>r"\n  by (metis concurrency_monotone2 refinement_'
         b'transitive small_exchange2)\ntheorem Hseqframe: "p\\<lbrace>q\\<rbr'
         b'ace>r \\<Longrightarrow> f;p\\<lbrace>q\\<rbrace>f;r"\n  by (metis s'
         b'emicolon_associative semicolon_monotone2)\n\nend\n\ntext {* Make the'
         b' time reversed versions of the theorems available. *}\nsublocale '
         b'hoarelogic < time_reverse!: hoarelogic "(op \\<sqsubseteq>)" "(op'
         b' \\<squnion>)" "(op \\<sqinter>)" "(\\<lambda> x y . y;x)" "(op \\<p'
         b'arallel>)" "\\<bottom>" "\\<top>" "skip" "iteration"\napply (rule h'
         b'oarelogic.intro)\napply (rule time_reversal)\napply (rule distr_th'
         b'rough_disj_p_def)\napply (rule lessthan_def)\nby (rule monotone_p_'
         b'def)\n\ntext {* Time-reversing the Hoare calculus yields another c'
         b'alculus. *}\nlocale newcalculus = hoarelogic\nbegin\ntheorem HseqTi'
         b'meReverse: "q\';r \\<sqsubseteq> s \\<Longrightarrow> q;p \\<sqsubse'
         b'teq> r \\<Longrightarrow> (q\';q);p \\<sqsubseteq> s"\n  by (metis t'
         b'ime_reverse.Hseq)\nend\n\nsection {* Milner-style semantics *}\nloca'
         b'le milner = hoarelogic\nbegin\n\nabbreviation (input) \n  milner_tri'
         b'ple :: "\'a \\<Rightarrow> \'a \\<Rightarrow> \'a \\<Rightarrow> b'
         b'ool"    ("_-_\\<rightarrow>_" [54,54,54] 53)\n  where "p-q\\<righta'
         b'rrow>r \\<equiv> q;r \\<sqsubseteq> p"\n\ntheorem Maction: "p-p\\'
         b'<rightarrow>skip"\n  by (metis Hskip)\ntheorem Mseq1: "p-q\\<righta'
         b'rrow>r \\<Longrightarrow> p;p\'-q\\<rightarrow>r;p\'"\n  by (meti'
         b's time_reverse.Hseqframe)\ntheorem Mseq2: "p-q\\<rightarrow>skip \\'
         b'<Longrightarrow> p;p\'-q\\<rightarrow>p\'"\n  by (metis Mseq1 semico'
         b'lon_left_unit)\ntheorem Mprefixing: "p;p\'-p\\<rightarrow>p\'"\n '
         b' by (metis Maction Mseq2)\n\nabbreviation (input)\n  milner_rearran'
         b'gement :: "\'a \\<Rightarrow> \'a \\<Rightarrow> bool"    ("_-\\<'
         b'rightarrow>_" [54,54] 53)\n  where "p-\\<rightarrow>q \\<equiv> p-s'
         b'kip\\<rightarrow>q"\n\nlemma rearrangement: "p-\\<rightarrow>q \\'
         b'<longleftrightarrow> q \\<sqsubseteq> p"\n  by (metis semicolon_le'
         b'ft_unit)\n\ntheorem Mchoice: "p\\<squnion>p\'-\\<rightarrow>p"\n  '
         b'by (metis disj_increasing1 rearrangement)\ntheorem Mchoice2: "p\\<'
         b'squnion>p\'-\\<rightarrow>p\'"\n  by (metis Mchoice disjunction_comm'
         b'utative)\ntheorem Miter1: "p\\<^sup>\\<star>-\\<rightarrow>skip"'
         b'\n  by (metis iter_unfold1 rearrangement)\ntheorem Miter2: "p\\<^su'
         b'p>\\<star>-\\<rightarrow>p;p\\<^sup>\\<star>"\n  by (metis iter_u'
         b'nfold2 rearrangement)\ntheorem Mconc1: "p-q\\<rightarrow>r \\<Longr'
         b'ightarrow> p\\<parallel>p\'-q\\<rightarrow>r\\<parallel>p\'"\n  by'
         b' (metis concurrency_commutative time_reverse.Hframe)\ntheorem Mco'
         b'nc2: "p-q\\<rightarrow>skip \\<Longrightarrow> p\\<parallel>p\'-'
         b'q\\<rightarrow>p\'"\n  by (metis Mconc1 concurrency_left_unit)\ntheo'
         b'rem Mconc3: "p-q\\<rightarrow>r \\<Longrightarrow> p\'\\<parallel>p-'
         b'q\\<rightarrow>p\'\\<parallel>r"\n  by (metis Mconc1 concurrency_com'
         b'mutative)\ntheorem Mconc4: "p-q\\<rightarrow>skip \\<Longrightarrow'
         b'> p\'\\<parallel>p-q\\<rightarrow>p\'"\n  by (metis Mconc2 concur'
         b'rency_commutative)\ntheorem Mseq: "p-q\\<rightarrow>r \\<Longrighta'
         b"rrow> r-q'\\<rightarrow>s \\<Longrightarrow> p-q;q'\\<rightarro"
         b'w>s"\n  by (metis time_reverse.Hseq)\ntheorem Mchoice\': "p-q\\<righ'
         b'tarrow>r \\<Longrightarrow> p\\<squnion>p\'-q\\<rightarrow>r"\n  '
         b'by (metis Mseq Mchoice semicolon_left_unit)\ntheorem Mcons: "p-\\<'
         b"rightarrow>p' \\<Longrightarrow> p'-q\\<rightarrow>r \\<Longrightar"
         b'row> r-\\<rightarrow>r\' \\<Longrightarrow> p-q\\<rightarrow>r\'"'
         b'\n  by (metis rearrangement time_reverse.Hcons)\n\nend\n\n\ntext {'
         b'* Make the time reversed versions of the theorems available. *}\n'
         b'sublocale milner < time_reverse!: milner "(op \\<sqsubseteq>)" "('
         b'op \\<squnion>)" "(op \\<sqinter>)" "(\\<lambda> x y . y;x)" "(op \\'
         b'<parallel>)" "\\<bottom>" "\\<top>" "skip" "iteration"\napply (rule'
         b' milner.intro)\napply (rule hoarelogic.intro)\napply (rule time_re'
         b'versal)\napply (rule distr_through_disj_p_def)\napply (rule lessth'
         b"an_def)\nby (rule monotone_p_def)\n\n\nsection {* Kahn's natural sem"
         b'antics *}\nlocale kahn = milner\nbegin\n\nabbreviation (input) \n'
         b'  kahn_triple :: "\'a \\<Rightarrow> \'a \\<Rightarrow> \'a \\<Rig'
         b'htarrow> bool" ("<_,_>\\<rightarrow>_" [54,54,54] 53)\n  where "<p'
         b',s>\\<rightarrow>s\' \\<equiv> s\' \\<sqsubseteq> s;p"\n\nlemma  Ki'
         b'mprovement: "p \\<sqsubseteq> p\' \\<Longrightarrow> <p,s>\\<rightar'
         b'row>s\' \\<Longrightarrow> <p\',s>\\<rightarrow>s\'"\n  by (metis '
         b'refinement_transitive semicolon_monotone2)\n\ntheorem Kskip: "<ski'
         b'p,s>\\<rightarrow>s"\n  by (metis refinement_reflexive semicolon_r'
         b'ight_unit)\ntheorem Kseq: "<p,s>\\<rightarrow>s\' \\<Longrightarrow>'
         b" <p',s'>\\<rightarrow>s'' \\<Longrightarrow> <p;p',s>\\<rightarrow>"
         b's\'\'"\n  by (metis refinement_transitive semicolon_associative sem'
         b'icolon_monotone1)\ntheorem Kchoice: "<p,s>\\<rightarrow>s\' \\<Longr'
         b'ightarrow> <p\\<squnion>p\',s>\\<rightarrow>s\'"\n  by (metis dis'
         b'j_increasing1 refinement_transitive semicolon_monotone2)\ntheorem'
         b' Kchoice\': "<p\',s>\\<rightarrow>s\' \\<Longrightarrow> <p\\<squn'
         b'ion>p\',s>\\<rightarrow>s\'"\n  by (metis Kchoice disjunction_commut'
         b'ative)\ntheorem Kiter1: "<p\\<^sup>\\<star>,s>\\<rightarrow>s"\n '
         b' by (metis Kimprovement iter_unfold1 refinement_reflexive semicolon_'
         b'right_unit)\ntheorem Kiter2: "<p,s>\\<rightarrow>s\' \\<Longrightarr'
         b"ow> <p\\<^sup>\\<star>,s'>\\<rightarrow>s'' \\<Longrightarrow> <"
         b'p\\<^sup>\\<star>,s>\\<rightarrow>s\'\'"\nproof -\n  assume a: "<p,'
         b's>\\<rightarrow>s\'"\n  assume b: "<p\\<^sup>\\<star>,s\'>\\<righta'
         b'rrow>s\'\'"\n  from a b have c: "<p;p\\<^sup>\\<star>,s>\\<rightar'
         b'row>s\'\'" by (rule Kseq)\n  from iter_unfold2 c show "<p\\<^sup'
         b'>\\<star>,s>\\<rightarrow>s\'\'" by (rule Kimprovement)\nqed\ntheo'
         b'rem Kconc1: "<p,s>\\<rightarrow>s\' \\<Longrightarrow> <p\',s\'>\\'
         b"<rightarrow>s'' \\<Longrightarrow> <p\\<parallel>p',s>\\<rightarrow"
         b'>s\'\'"\n  by (metis Kimprovement Kseq seq_refines_conc)\ntheorem Kc'
         b'onc2: "<p\',s>\\<rightarrow>s\' \\<Longrightarrow> <p,s\'>\\<right'
         b"arrow>s'' \\<Longrightarrow> <p\\<parallel>p',s>\\<rightarrow>s"
         b'\'\'"\n  by (metis Kconc1 concurrency_commutative)\n\nend\n',
 'links': [],
 'pid': 1556,
 'url': 'http://www0.cs.ucl.ac.uk/staff/s.vanstaden/proofs/LawsOfProgrammingUnifyProcessCalculi.thy'}