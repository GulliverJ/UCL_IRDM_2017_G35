{'html': b'<html>\n<head>\n<title>Theory AlphaZero (Isabelle99-1: October 200'
         b'0)</title>\n</head>\n\n<body>\n<h1>Theory AlphaZero</h1>\n\n\n<p>\n<'
         b'a href="index.html">Up</a> to index of Isabelle/HOL/raw-confluence-l'
         b'ambda\n</p>\n<b>theory</b> <i>AlphaZero</i> = <a href="Lambda.html'
         b'"><i>Lambda</i></a> + <a href="Alpha.html"><i>Alpha</i></a><br><b>fi'
         b'les</b> <a href="AlphaZero.ML.html">[<tt>AlphaZero.ML</tt>]</a>:'
         b'\n\n<hr>\n<pre>(*  Title:      AlphaZero.thy\n    Author:     James '
         b'Brotherston / Rene Vestergaard\n    Revised:    30th August, 2000'
         b'\n\n- We first present two different reflexive/transitive closures'
         b' of the indexed\n  alpha relation.  The first insists that the sa'
         b'me name be chosen for each\n  alpha reduction; the second allows '
         b'the use of different names and accumulates\n  them in a list.  Bo'
         b'th versions are essential in proving key lemmas later.\n\n- We als'
         b'o present two versions of the alpha-0 relation.  The first is simply'
         b'\n  indexed alpha with an additional fresh-naming requirement.  T'
         b'he second (which\n  for simplicity we call alpha-1) is defined in'
         b'dependently and is reflexive.\n  However, the reflexive/transitiv'
         b'e closures of alpha-0 and alpha-1 are\n  completely equivalent.\n\n'
         b'*)\n\n\nAlphaZero = Lambda + Alpha +\n  \nconsts  rt_ialpha  :: "'
         b'(lterm * var * lterm) set"\n        cl_ialpha  :: "(lterm * var l'
         b'ist * lterm) set"\n        i_alpha0   :: "(lterm * var * lterm) s'
         b'et"\n        alpha0     :: "(lterm * lterm) set"\n        i_alpha1'
         b'   :: "(lterm * var * lterm) set"\n        cl_ialpha1 :: "(lterm '
         b'* var list * lterm) set"\n  \nsyntax  "-&gt;&gt;iA"         :: [lt'
         b'erm,var,lterm] =&gt; bool (infixl 50)\n        "-&gt;&gt;ciA"    '
         b'    :: [lterm,var list,lterm] =&gt; bool (infixl 50)\n        "-&'
         b'gt;iA0","-&gt;iA1" :: [lterm,var,lterm] =&gt; bool (infixl 50)\n '
         b'       "-&gt;A0", "-&gt;&gt;A0" :: [lterm,lterm] =&gt; bool (infixl '
         b'50)\n        "-&gt;&gt;iA1"        :: [lterm,var list,lterm] =&gt'
         b'; bool (infixl 50)\n  \ntranslations\n  "(s,x) -&gt;&gt;iA t" == "('
         b's,x,t) : rt_ialpha"\n  "(s,x) -&gt;iA0 t" == "(s,x,t) : i_alpha0"'
         b'\n  "s -&gt;A0 t"      == "(s,t) : alpha0"\n  "s -&gt;&gt;A0 t"   '
         b'  == "(s,t) : alpha0^*"\n  "(s,x) -&gt;iA1 t"   == "(s,x,t) : i_a'
         b'lpha1"\n  "(s,xs) -&gt;&gt;iA1 t" == "(s,xs,t) : cl_ialpha1"\n  "('
         b's,xs) -&gt;&gt;ciA t"  == "(s,xs,t) : cl_ialpha"\n\ninductive rt_i'
         b'alpha (* requires we use the same alpha-name each time *)\nintrs\n'
         b'  refl   "(s,y) -&gt;&gt;iA s"\n  trans  "[|(s,y) -&gt;&gt;iA t; '
         b'(t,y) -&gt;iA u|] ==&gt; (s,y) -&gt;&gt;iA u"\n\ninductive cl_ialp'
         b'ha (* accumulates list of used alpha-names *)\nintrs\n  refl   "(e'
         b',[]) -&gt;&gt;ciA e"\n  trans  "[|(e1,xs) -&gt;&gt;ciA e2; (e2,x)'
         b' -&gt;iA e3|] ==&gt; (e1,x#xs) -&gt;&gt;ciA e3"\n \ninductive i_al'
         b'pha0  (* i_alpha with a variable fresh-naming requirement *)\nint'
         b'rs\n  ialpha0 "[|(s,y) -&gt;iA t; y~:(FV(s) Un BV(s))|] ==&gt; (s'
         b',y) -&gt;iA0 t" \n  \ninductive alpha0    \nintrs\n  strip   "(s,y) '
         b'-&gt;iA0 t ==&gt; s -&gt;A0 t"\n\ninductive i_alpha1  (* essential'
         b'ly the same as i_alpha0, but reflexive  *)\nintrs\n  var    "x~=y '
         b'==&gt; (Var x,y) -&gt;iA1 Var x"\n  contr  "y~:(BV(Abs x e) Un FV'
         b'(Abs x e)) ==&gt;\n          (Abs x e,y) -&gt;iA1 Abs y (e[x:=Var'
         b' y])"\n  abs    "[|(e,y) -&gt;iA1 e\'; x~=y|] ==&gt; (Abs x e,y) -'
         b'&gt;iA1 Abs x e\'"\n  appL   "[|(e1,y) -&gt;iA1 e1\'; y~:(BV(e2) Un'
         b' FV(e2))|] ==&gt;\n          (e1 $ e2,y) -&gt;iA1 e1\' $ e2"\n  app'
         b'R   "[|(e2,y) -&gt;iA1 e2\'; y~:(BV(e1) Un FV(e1))|] ==&gt;\n     '
         b'     (e1 $ e2,y) -&gt;iA1 e1 $ e2\'"\n\ninductive cl_ialpha1 (* equ'
         b'ivalent to (alpha0)^* *)\nintrs\n  refl   "(e,[]) -&gt;&gt;iA1 e"\n'
         b'  trans  "[|(e1,xs) -&gt;&gt;iA1 e2; (e2,x) -&gt;iA1 e3|] ==&gt; (e1'
         b',x#xs) -&gt;&gt;iA1 e3"\n\n\nend</pre>\n<hr>\n\n<p>\n<b>theorem</b>'
         b' <i>rt_ialpha_base:</i>\n<pre>  (<font color="blue">s</font>, <fo'
         b'nt color="blue">y</font>) -&gt;iA <font color="blue">t</font> ==&gt;'
         b' (<font color="blue">s</font>, <font color="blue">y</font>) -&gt;&gt'
         b';iA <font color="blue">t</font></pre>\n</p>\n\n<p>\n<b>theorem</b> <'
         b'i>rt_ialpha_in_alpha:</i>\n<pre>  (<font color="blue">s</font>, <'
         b'font color="blue">y</font>) -&gt;&gt;iA <font color="blue">t</font> '
         b'==&gt; <font color="blue">s</font> -&gt;&gt;A <font color="blue">t</'
         b'font></pre>\n</p>\n\n<p>\n<b>theorem</b> <i>rt_ialpha_abs:</i>\n<'
         b'pre>  (<font color="blue">s</font>, <font color="blue">y</font>) -&g'
         b't;&gt;iA <font color="blue">t</font> ==&gt; (Abs <font color="blue">'
         b'x</font> <font color="blue">s</font>, <font color="blue">y</font>) -'
         b'&gt;&gt;iA Abs <font color="blue">x</font> <font color="blue">t</fon'
         b't></pre>\n</p>\n\n<p>\n<b>theorem</b> <i>rt_ialpha_appL:</i>\n<pr'
         b'e>  (<font color="blue">s</font>, <font color="blue">y</font>) -&gt;'
         b'&gt;iA <font color="blue">t</font> ==&gt; (<font color="blue">s</fon'
         b't> $ <font color="blue">u</font>, <font color="blue">y</font>) -&gt;'
         b'&gt;iA <font color="blue">t</font> $ <font color="blue">u</font></pr'
         b'e>\n</p>\n\n<p>\n<b>theorem</b> <i>rt_ialpha_appR:</i>\n<pre>  (<'
         b'font color="blue">s</font>, <font color="blue">y</font>) -&gt;&gt;iA'
         b' <font color="blue">t</font> ==&gt; (<font color="blue">u</font> $ <'
         b'font color="blue">s</font>, <font color="blue">y</font>) -&gt;&gt;iA'
         b' <font color="blue">u</font> $ <font color="blue">t</font></pre>'
         b'\n</p>\n\n<p>\n<b>theorem</b> <i>rt_ialpha_bigtrans:</i>\n<pre>  '
         b'(<font color="blue">t</font>, <font color="blue">y</font>) -&gt;&gt;'
         b'iA <font color="blue">u</font> ==&gt; ALL <font color="green">s</fon'
         b't>. (<font color="green">s</font>, <font color="blue">y</font>) -&gt'
         b';&gt;iA <font color="blue">t</font> --&gt; (<font color="green">s</f'
         b'ont>, <font color="blue">y</font>) -&gt;&gt;iA <font color="blue">u<'
         b'/font></pre>\n</p>\n\n<p>\n<b>theorem</b> <i>rt_ialpha_bigtrans:</i>'
         b'\n<pre>  [| (<font color="blue">s</font>, <font color="blue">y</f'
         b'ont>) -&gt;&gt;iA <font color="blue">t</font>; (<font color="blue">t'
         b'</font>, <font color="blue">y</font>) -&gt;&gt;iA <font color="blue"'
         b'>u</font> |] ==&gt; (<font color="blue">s</font>, <font color="blue"'
         b'>y</font>) -&gt;&gt;iA <font color="blue">u</font></pre>\n</p>\n\n<'
         b'p>\n<b>theorem</b> <i>rt_ialpha_doubleApp:</i>\n<pre>  (<font colo'
         b'r="blue">s1</font>, <font color="blue">y</font>) -&gt;&gt;iA <font c'
         b'olor="blue">t1</font> ==&gt; (<font color="blue">s2</font>, <font co'
         b'lor="blue">y</font>) -&gt;&gt;iA <font color="blue">t2</font> --&gt;'
         b' (<font color="blue">s1</font> $ <font color="blue">s2</font>, <font'
         b' color="blue">y</font>) -&gt;&gt;iA <font color="blue">t1</font> $ <'
         b'font color="blue">t2</font></pre>\n</p>\n\n<p>\n<b>theorem</b> <i>ia'
         b'lpha_FV_lemma:</i>\n<pre>  (<font color="blue">s</font>, <font co'
         b'lor="blue">y</font>) -&gt;iA <font color="blue">t</font> ==&gt; FV <'
         b'font color="blue">t</font> = FV <font color="blue">s</font></pre'
         b'>\n</p>\n\n<p>\n<b>theorem</b> <i>rt_ialpha_FV_lemma:</i>\n<pre> '
         b' (<font color="blue">s</font>, <font color="blue">y</font>) -&gt;&gt'
         b';iA <font color="blue">t</font> ==&gt; FV <font color="blue">s</font'
         b'> = FV <font color="blue">t</font></pre>\n</p>\n\n<p>\n<b>theorem</b'
         b'> <i>BV_subst_lemma_2:</i>\n<pre>  Capt <font color="blue">x</fon'
         b't> <font color="blue">e</font> Int FV <font color="blue">e\'</fon'
         b't> = {} --&gt;\n  BV (<font color="blue">e</font>[<font color="bl'
         b'ue">x</font>:=<font color="blue">e\'</font>]) = (if <font color="'
         b'blue">x</font> : FV <font color="blue">e</font> then BV <font color='
         b'"blue">e</font> Un BV <font color="blue">e\'</font> else BV <font'
         b' color="blue">e</font>)</pre>\n</p>\n\n<p>\n<b>theorem</b> <i>i_alph'
         b'a_BV_lemma_1:</i>\n<pre>  (<font color="blue">s</font>, <font col'
         b'or="blue">y</font>) -&gt;iA <font color="blue">t</font> ==&gt; BV <f'
         b'ont color="blue">t</font> &lt;= BV <font color="blue">s</font> Un {<'
         b'font color="blue">y</font>}</pre>\n</p>\n\n<p>\n<b>theorem</b> <i>ia'
         b'lpha1_in_rt_ialpha:</i>\n<pre>  (<font color="blue">s</font>, <fo'
         b'nt color="blue">y</font>) -&gt;iA1 <font color="blue">t</font> ==&gt'
         b'; (<font color="blue">s</font>, <font color="blue">y</font>) -&gt;&g'
         b't;iA <font color="blue">t</font></pre>\n</p>\n\n<p>\n<b>theorem</b> '
         b'<i>ialpha1_FV_lemma:</i>\n<pre>  (<font color="blue">s</font>, <f'
         b'ont color="blue">y</font>) -&gt;iA1 <font color="blue">t</font> ==&g'
         b't; FV <font color="blue">s</font> = FV <font color="blue">t</font></'
         b'pre>\n</p>\n\n<p>\n<b>theorem</b> <i>ialpha1_BV_lemma:</i>\n<pre>'
         b'  (<font color="blue">s</font>, <font color="blue">y</font>) -&gt;iA'
         b'1 <font color="blue">t</font> ==&gt; BV <font color="blue">t</font> '
         b'&lt;= BV <font color="blue">s</font> Un {<font color="blue">y</font>'
         b'}</pre>\n</p>\n\n<p>\n<b>theorem</b> <i>cl_ialpha_FV_lemma:</i>\n'
         b'<pre>  (<font color="blue">s</font>, <font color="blue">ys</font>) -'
         b'&gt;&gt;ciA <font color="blue">t</font> ==&gt; FV <font color="blue"'
         b'>s</font> = FV <font color="blue">t</font></pre>\n</p>\n\n<p>\n<b>th'
         b'eorem</b> <i>cl_ialpha_BV_lemma:</i>\n<pre>  (<font color="blue">'
         b's</font>, <font color="blue">ys</font>) -&gt;&gt;ciA <font color="bl'
         b'ue">t</font> ==&gt; BV <font color="blue">t</font> &lt;= BV <font co'
         b'lor="blue">s</font> Un set <font color="blue">ys</font></pre>\n</'
         b'p>\n\n<p>\n<b>theorem</b> <i>cl_ialpha1_trans2:</i>\n<pre>  (<font c'
         b'olor="blue">t</font>, <font color="blue">ys</font>) -&gt;&gt;iA1 <fo'
         b'nt color="blue">u</font> ==&gt; ALL <font color="green">s</font> <fo'
         b'nt color="green">y</font>. (<font color="green">s</font>, <font colo'
         b'r="green">y</font>) -&gt;iA1 <font color="blue">t</font> --&gt; (<fo'
         b'nt color="green">s</font>, <font color="blue">ys</font> @ [<font col'
         b'or="green">y</font>]) -&gt;&gt;iA1 <font color="blue">u</font></pre>'
         b'\n</p>\n\n<p>\n<b>theorem</b> <i>cl_ialpha1_trans2:</i>\n<pre>  ['
         b'| (<font color="blue">s</font>, <font color="blue">y</font>) -&gt;iA'
         b'1 <font color="blue">t</font>; (<font color="blue">t</font>, <font c'
         b'olor="blue">ys</font>) -&gt;&gt;iA1 <font color="blue">u</font> |] ='
         b'=&gt; (<font color="blue">s</font>, <font color="blue">ys</font> @ ['
         b'<font color="blue">y</font>]) -&gt;&gt;iA1 <font color="blue">u</fon'
         b't></pre>\n</p>\n\n<p>\n<b>theorem</b> <i>ialpha1_to_ialpha0:</i>'
         b'\n<pre>  (<font color="blue">e1</font>, <font color="blue">y</fon'
         b't>) -&gt;iA1 <font color="blue">e2</font> ==&gt; <font color="blue">'
         b'e1</font> ~= <font color="blue">e2</font> --&gt; (<font color="blue"'
         b'>e1</font>, <font color="blue">y</font>) -&gt;iA0 <font color="blue"'
         b'>e2</font></pre>\n</p>\n\n<p>\n<b>theorem</b> <i>rt_ialpha1_to_rt_ia'
         b'lpha0:</i>\n<pre>  (<font color="blue">e</font>, <font color="blu'
         b'e">xs</font>) -&gt;&gt;iA1 <font color="blue">e\'</font> ==&gt; <'
         b'font color="blue">e</font> -&gt;&gt;A0 <font color="blue">e\'</fo'
         b'nt></pre>\n</p>\n\n<p>\n<b>theorem</b> <i>rt_alpha_to_rt_ialpha:</i>'
         b'\n<pre>  <font color="blue">e</font> -&gt;&gt;A <font color="blue'
         b'">e\'</font> ==&gt; EX <font color="green">xs</font>. (<font colo'
         b'r="blue">e</font>, <font color="green">xs</font>) -&gt;&gt;ciA <font'
         b' color="blue">e\'</font></pre>\n</p>\n\n<p>\n<b>theorem</b> <i>ia'
         b'lpha1_var_subst:</i>\n<pre>  (<font color="blue">e</font>, <font '
         b'color="blue">z</font>) -&gt;iA1 <font color="blue">e\'</font>\n  ='
         b'=&gt; <font color="blue">y</font> ~= <font color="blue">z</font> --&'
         b'gt; <font color="blue">y</font> ~: Capt <font color="blue">x</font> '
         b'<font color="blue">e</font> --&gt; (<font color="blue">e</font>[<fon'
         b't color="blue">x</font>:=Var <font color="blue">y</font>], <font col'
         b'or="blue">z</font>) -&gt;iA1 <font color="blue">e\'</font>[<font '
         b'color="blue">x</font>:=Var <font color="blue">y</font>]</pre>\n</'
         b'p>\n\n</body>\n</html>\n',
 'links': [1614, 1667, 1663, 2483],
 'pid': 1664,
 'url': 'http://www0.cs.ucl.ac.uk/staff/J.Brotherston/confluence_VB/AlphaZero.html'}