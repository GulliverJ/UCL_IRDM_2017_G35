{'html': '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">\n<HTML>\n<HEAD>\n    <!-- SGI_COMMENT COSMOCREATE -->\n    <!-- SGI_COMMENT VERSION NUMBER="1.0.2" -->\n    <TITLE>Querying Points on a Hemisphere</TITLE>\n</HEAD>\n<BODY>\n<H1>\nConstant Time Queries on Uniformly Distributed Points on a Hemisphere</H1>\n<P>\n<A HREF="http://www.cs.ucl.ac.uk/staff/m.slater">Mel Slater</A></P>\n<H2>\nSoftware</H2>\n<P>\nThere is an illustrative implemention of the algorithm described in the \npaper. It has been developed and tested on a SGI O2 MIPS R5000, Rev 2. \nIt has also been executed on a Toshiba Portege 7200 Series laptop with <A\n HREF="http://www.msdn.microsoft.com">Microsoft Visual C++ 6.0</A> - on \nwhich it still works, but there are more reported errors. This is \nprobably to do with differences in floating point precision between the \ntwo machines.</P>\n<P>\nThe implementation makes use of <A\n HREF="http://reality.sgi.com/opengl/">OpenGL</A> and the <A\n HREF="http://reality.sgi.com/opengl/glut3/glut3.html">GLUT</A>\n library. It also makes use of a 3D graphics library developed for \nteaching, which for convenience provides some basic data structures \nsuch as Point3D, and also a camera model. There is <A\n HREF="http://www.cs.ucl.ac.uk/staff/m.slater/Teaching/Lib3D">some \ndocumentation </A>for this library, though only very few of its data \nstructures and functions are used here, and they should be obvious.</P>\n<P>\nThe main program, uniform sphere and query point implementation are in \nQuerySphere and the graphics library is in Lib3D.</P>\n<P>\nThe query sphere implementation writes polygons with RGB floating point \nvalues into the frame buffer and then reads them out using \nglReadPixels. The implementation relies obviously on exactly the same \nfloating RGB point values being extracted from the framebuffer as went \ninto it.<BR>\nThe implementation assumes that the floating point values that can be \nrepresented are uniformly distributed in the space available in the \nnumber of bits for each of the colours. For example, on the Toshiba \nPortege, a glGetIntegerv on GL_RED_BITS delivers 5 as the number of \nbits for red. It is assumed that floating point values available for \nred between 0.0 and 1.0 are therefore i/31.0 (i=0,1,...,31) on this \nmachine. This type of calculation gives correct results on both the SGI\nand the Portege. Note that OpenGL does transform the data stored in the \nframebuffer in various ways (eg, see the documentation for \nglReadPixels) so that it is important to check this.</P>\n<P>\nAnother simple program (colortest) simply fills a window with a color \nwith speficied RGB values decoded from an arbitrary integer and then \nreads back the framebuffer and prints out the RGB values obtained and \nthe reconstruction of the integer code. If this program does not work \nthen nor will the query sphere program.</P>\n<P>\n<A HREF="QuerySphere.tar.gz">QuerySphere.tar.gz</A></P>\n<P>\n<A HREF="Lib3D.tar.gz">Lib3D.tar.gz</A></P>\n<P>\n</P>\n</BODY>\n</HTML>\n',
 'pid': 290,
 'url': 'http://www0.cs.ucl.ac.uk/staff/M.Slater/Papers/Sphere/Code/'}