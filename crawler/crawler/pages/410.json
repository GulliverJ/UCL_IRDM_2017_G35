{'html': '\n#include <GL/glut.h>\n \n/*\n  An example of using OpenGL to render a simple object with\n  a texture. The texture is saved in a ppm format file.\n  You can also use the program dmconvert to tell you more about\n  the image file.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\r\n#include <string.h>\n\n/*This next is referred to in several places, and because of the callback\ninterface, cannot be passed as a parameter, hence, global*/\n\n/*WARNING - using the PPM file format, and you must delete the first few lines of text\nstarting only from the image size data*/\n\ntypedef GLubyte Pixel[3]; /*represents red green blue*/\n\n\nint Width, Height; /*of image*/\n\n/*array of pixels*/\nPixel *Image;\n\n/*name of image file*/\r\nchar *Filename = "../default.ppm";\n\nint allowedSize(int x)\n/*returns max power of 2 <= x*/\n{\n\tint r;\n\t\n\tr = 1;\n\twhile(r < x) r=(r<<1);\n\t\n\tif(r==x) return r;\t\n\telse return r>>1;\n}\n\nvoid readImage(void)\n/*reads the image file assumes ppm format*/\n{\n\t\n\tint w,h,max;\n\tint i,j;\n\tunsigned int r,g,b;\n\tint k;\r\n\tchar ch;\n\tFILE *fp;\n\t\n\tfp = fopen(Filename,"r");\n\t\n\tprintf("filename = %s\\n",Filename);\r\n\r\n\t/*read the header*/\r\n\t\r\n    fscanf(fp, "P%c\\n", &ch);\r\n\tif (ch != \'3\') {\r\n\t\tfprintf(stderr, "Only ascii mode 3 channel PPM files");\r\n\t\texit(-1);\r\n\t}\r\n\r\n\t/*strip comment lines*/\r\n\tch = getc(fp);\r\n\twhile (ch == \'#\') {\r\n      do {\r\n\t\t  ch = getc(fp);\r\n      }\r\n\t  while (ch != \'\\n\');\r\n      ch = getc(fp); \r\n    }\r\n\tungetc(ch, fp);\r\n\r\n\t/*read the width*/\n\tfscanf(fp,"%d",&w);\n\t\n\t/*read the height*/\n\tfscanf(fp,"%d",&h);\n\t\n\t/*max intensity - not used here*/\n\tfscanf(fp,"%d",&max);\n\t\n\t/*width and height must be powers of 2 - taking the simple option\n\there of finding the max power of 2 <= w and h*/\n\n\tWidth = allowedSize(w);\n\tHeight = allowedSize(h);\n\t\n\tprintf("Width = %d, Height = %d\\n",Width,Height);\n\t\n\tImage = (Pixel *)malloc(Width*Height*sizeof(Pixel));\n\t\n\t\n\tfor(i=0;i<Height;++i){\n\t\tfor(j=0;j<Width;++j) {\n\t\t\tfscanf(fp,"%d %d %d",&r,&g,&b);\n\t\t\tk = i*Width+j; /*ok, can be more efficient here!*/\n\t\t\t(*(Image+k))[0] = (GLubyte)r;\n\t\t\t(*(Image+k))[1] = (GLubyte)g;\n\t\t\t(*(Image+k))[2] = (GLubyte)b;\n\t\t}\n\t\t/*better scan to the end of the row*/\n\t\tfor(j=Width; j<w; ++j) fscanf(fp,"%c %c %c",&r,&g,&b);\n\t}\n\tfclose(fp);\n}\n\n\nvoid initialiseTextures(void)\n{\n\tGLint level = 0;      /*only one level - no level of detail*/\n\tGLint components = 3; /*3 means R, G, and B components only*/\n\tGLint border = 0;     /*no border around the image*/\n\t\n\t/*read the image file*/\n\treadImage();\n\t\n\t/*each pixelrow on a byte alignment boundary*/\n\tglPixelStorei(GL_UNPACK_ALIGNMENT,1);\n\t\n\t/*define information about the image*/\n\tglTexImage2D(GL_TEXTURE_2D,level,components,\n\t\t\t(GLsizei)Width, (GLsizei)Height,\n\t\t     \tborder, GL_RGB, GL_UNSIGNED_BYTE,Image);\n\n\t/*ensures that image is not wrapped*/\n\tglTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);\n\tglTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);\n\t\n\t/*chooses mapping type from texels to pixels*/\n\tglTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);\n\tglTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);\n\t/*this says for minification and magnfication choose texel that \r\n\tGL_NEAREST chooses the texel nearest the centre of the pixel\r\n\tis nearest to the centre of the pixel, rather than GL_LINEAR which\r\n\tperforms a linear interpolation on the 4 surrounding texels*/\n\t\n\t/*GL_DECAL - this says overwrite pixel with texture colour*/\n\tglTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);\n\t/*an alternative is GL_MODULATE which modulates the lighting\n\tby the texel value by multiplication*/\n\t\n\t/*this enables texturing*/\n\tglEnable(GL_TEXTURE_2D);\n}\n\t\n\t\n\t\n\nstatic void cubebase(void)\n/*specifies a side of a cube*/\n{\n\tglBegin(GL_POLYGON);\n\t\tglTexCoord2f(0.0,0.0);\n\t\tglVertex3d(-0.5,-0.5,0.0);\n\t\t\n\t\tglTexCoord2f(0.0,1.0);\n\t\tglVertex3d(-0.5,0.5,0.0);\n\t\t\n\t\tglTexCoord2f(1.0,1.0);\n\t\tglVertex3d(0.5,0.5,0.0);\n\t\t\n\t\tglTexCoord2f(1.0,0.0);\n\t\tglVertex3d(0.5,-0.5,0.0);\n\tglEnd();\n}\n\nstatic void cube(void)\n/*uses cube side to construct a cube, making use of the modelview matrix*/\n{\n\t/*make sure we\'re dealing with modelview matrix*/\n\tglMatrixMode(GL_MODELVIEW);\n\t        \n\t/*pushes and duplicates current matrix*/\n\tglPushMatrix();\n\t\n\t\n\t/*construct the base*/\n\tcubebase();\n\t\n\tglPushMatrix();\n\t/*construct side on +x axis*/\n\tglTranslated(0.5,0.0,0.5);\n\tglRotated(90.0,0.0,1.0,0.0);\n\tcubebase();\n\t\n\tglPopMatrix();\n\n\t/*construct side on -x axis*/\n\tglPushMatrix();\n\tglTranslated(-0.5,0.0,0.5);\n\tglRotated(-90.0,0.0,1.0,0.0);\n\tcubebase();\n\tglPopMatrix();\n\n\t/*construct side on +y axis*/\n\tglPushMatrix();\n\tglTranslated(0.0,0.5,0.5);\n\tglRotated(-90.0,1.0,0.0,0.0);\n\tcubebase();\n\tglPopMatrix();\n\t\n\t/*construct side on -y axis*/\n\tglPushMatrix();\n\tglTranslated(0.0,-0.5,0.5);\n\tglRotated(90.0,1.0,0.0,0.0);\n\tcubebase();\n\tglPopMatrix();\n\n\t/*construct top*/ \n\t\n\tglBegin(GL_POLYGON);\n\t\tglTexCoord2f(0.0,0.0);\n\t\tglVertex3d(-0.5,-0.5,1.0);\n\t\t\n\t\tglTexCoord2f(1.0,0.0);\n\t\tglVertex3d(0.5,-0.5,1.0);\n\t\t\n\t\tglTexCoord2f(1.0,1.0);\n\t\tglVertex3d(0.5,0.5,1.0);\n\t\t\n\t\tglTexCoord2f(0.0,1.0);\n\t\tglVertex3d(-0.5,0.5,1.0);\n\tglEnd();\n\t\n\t\n\tglPopMatrix();\n\t\n\tglFlush();\n}\n\nstatic void stack(int n)\n/*creates a smaller cube on top of larger one*/\n{\n\t\n\tcube();\n\tif(n==0)return;\n\t\n\tglPushMatrix();\n\tglTranslated(0.0,0.0,1.0);\n\tglScaled(0.5,0.5,0.5);\n\tstack(n-1);\n\tglPopMatrix();\n}\n\t\n\n\nstatic void display(void)\n{\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\tstack(2);\n\tglutSwapBuffers();\n\n}\n\n\t\nstatic void rotate(void)\n/*rotates around z-axis*/\n{\n\tstatic GLdouble a = 0.0;\n\t\n\t/*make sure we\'re dealing with modelview matrix*/\n\tglMatrixMode(GL_MODELVIEW);\n\tglPushMatrix();\n\tglRotated(a,0.0,0.0,1.0);\n\tcube();\n\tdisplay();\n\tglPopMatrix();\n\ta += 1.0;\n}\n\n \nstatic void reshape(GLsizei width, GLsizei height)\n{ \t\n\t/*define the viewport - width and height of display window*/\n\tglViewport (0, 0, width, height);\n\n\tglMatrixMode(GL_PROJECTION);\n\tglLoadIdentity();\n\t/*define view frustrum*/\n\tgluPerspective(50.0,(GLdouble)width/(GLdouble)height,0.01,10.0);\n\t/*35deg field of view vertically, with aspect ratio, and \n        front and back clipping planes of -1.0 and 10.0*/\n}\n\t\nstatic void initialise(void) \n{\n\t/*material properties*/\n\tGLfloat mat_diffuse[] = {1.0,1.0,0.0,0.0};\n\n\t/*lighting*/\n\tGLfloat light_diffuse[] = {1.0,1.0,1.0,1.0};\n\n\t/*light position*/\n\tGLfloat position[] = {1.0,1.0,4.0,1.0};\n\n\t/*flat shading*/\n    \tglShadeModel (GL_FLAT);\n\n\t/*create normals normalised and automatically*/\n\tglEnable(GL_NORMALIZE);\n\tglEnable(GL_AUTO_NORMAL);\n\n    \t/*set the background (clear) Color to white*/\n    \tglClearColor(1.0,1.0,1.0,0.0);\n\n\t\n\t/*for 2D the modelview matrix is the identity*/\n\tglMatrixMode(GL_MODELVIEW);\n\tglLoadIdentity();\n\t\n\tgluLookAt(3.0,3.0,4.0,\t\t/*eye*/\n\t\t  0.0,0.0,0.0,\t\t/*looking here*/\n\t\t  0.0, 0.0, 1.0);\t/*up vector*/\n\t\t  \n\t/*enable lighting*/\n\tglEnable(GL_LIGHTING);\n\tglEnable(GL_LIGHT0);\n\t\n\t/*set the light position coordinates*/\n\tglPushMatrix();\n\tglLoadIdentity();\n\tglLightfv(GL_LIGHT0,GL_POSITION,position);\n\tglPopMatrix();\n\t\n\t/*set the material*/\n\tglMaterialfv(GL_FRONT,GL_DIFFUSE,mat_diffuse);\n\t\n\tglLightfv(GL_LIGHT0,GL_DIFFUSE,light_diffuse);\n    \n    \t/*enable the depth buffer*/\n    \tglEnable(GL_DEPTH_TEST);\n    \n    \t/*set the depth buffer for clearing*/\n    \tglClearDepth(1.0);\n    \t\n    \t/*initialise the texture map*/\n    \tinitialiseTextures();\n    \t\n}\n\n     \nint main(int argc, char** argv)\n{\t\n\tint window;\n\t\n\tglutInit(&argc,argv);\n\n\tglutInitWindowSize(500,500);     \n\tglutInitDisplayMode(GLUT_RGBA|GLUT_DOUBLE|GLUT_DEPTH);\n\n\n\twindow = glutCreateWindow("Textured Stack ");\n\tglutSetWindow(window);\n\n    \tinitialise();\n\n\t/*register callbacks*/\n\tglutDisplayFunc(display); /*display function*/\n\tglutReshapeFunc(reshape);\n\tglutIdleFunc(rotate);\n\n\tglutMainLoop();\n}\n',
 'pid': 410,
 'url': 'http://www0.cs.ucl.ac.uk/staff/A.Steed/book_tmp/CGVE/code/Lib3D1.0/maintexture.c'}