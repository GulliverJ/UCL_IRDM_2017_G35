{'html': b'<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE html\n    PUBLIC'
         b' "-//W3C//DTD XHTML 1.0 Transitional//EN"\n    "http://www.w3.org'
         b'/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n<html xml:lang="en" lan'
         b'g="en" xmlns="http://www.w3.org/1999/xhtml">\n<head>\n\n<meta http-'
         b'equiv="Content-Type" content="text/html; charset=utf-8" />\n<!-- '
         b'\n\tThis website is powered by TYPO3 - inspiring people to share!\n'
         b'\tTYPO3 is a free open source Content Management Framework initia'
         b'lly created by Kasper Skaarhoj and licensed under GNU/GPL.\n\tTYPO'
         b'3 is copyright 1998-2016 of Kasper Skaarhoj. Extensions are copyrigh'
         b't of their respective owners.\n\tInformation and contribution at h'
         b'ttp://typo3.org/\n-->\n\n<base href="http://pplv.cs.ucl.ac.uk/" />\n'
         b'\n<title>UCL-CS PPLV: Research Seminars</title>\n<meta name="gener'
         b'ator" content="TYPO3 CMS" />\n\n\n<link rel="stylesheet" type="text'
         b'/css" href="typo3temp/stylesheet_e94adc7020.css?1447625393" media="a'
         b'll" />\n\n\n<script src="uploads/tx_t3jquery/jquery-1.8.x-1.9.x-1.2'
         b'.x.js?1383917144" type="text/javascript"></script>\n\n\n\n<link rel='
         b'"stylesheet" href="fileadmin/pplv/templates/css/uclonline_medium.css'
         b'" type="text/css" />\n</head>\n<body>\n\r\n\r\n<div id="banner"'
         b'> \r\n  <div id="tb-black" style="height: 110px;"> \r\n    <div id="'
         b'section_heading"> \r\n      <div id="section_head">\r\n    <span id='
         b'"section_header_white" style="text-transform:uppercase;"><big>Progra'
         b'mming Principles, Logic, and \r\n        Verification Group </big>'
         b'</span><br /> \r\n     \r\n        <span id="section_subheader_white'
         b'" style="text-transform:uppercase;"></span></div><span id="section_s'
         b'ubheader_white" style="text-transform:uppercase;"><big>Department of'
         b' Computer Science</big></span></div> \r\n    </div> \r\n    <div id='
         b'"logo_holder"> \r\n      <div id="logo"><a href="http://www.ucl.ac'
         b'.uk/"> <img src="fileadmin/pplv/templates/images/ucl0016.gif" alt="U'
         b'CL Logo" /></a></div> \r\n    </div> \r\n  </div> \r\n</div> \r\n<!-'
         b'- Begin top_navigation slot -->\r\n<div id="ucl0016"> \r\n  <div id='
         b'"search"> \r\n<div class="tx-macinasearchbox-pi1">\n\t\t\n<form ac'
         b'tion="search/?L=0" method="post" id="googlesearch">\n<input name='
         b'"tx_indexedsearch[sword]" type="text" id="q" value="Search" tabindex'
         b'="1" accesskey="q" onclick="document.forms[0].q.value=\'\'" />\n   '
         b'     <input type="hidden" name="tx_indexedsearch[_sections]" value="'
         b'0" />\n        <input type="hidden" name="tx_indexedsearch[pointe'
         b'r]" value="0" />\n        <input type="hidden" name="tx_indexedse'
         b'arch[ext]" value="0" />\n        <input type="hidden" name="tx_in'
         b'dexedsearch[lang]" value="0" />\n</form>\n\n\t</div>\n\t\r\n  </div>'
         b' \r\n  <p class="breadcrumb"><span id="bcpadding">   <a href="http'
         b'://www.ucl.ac.uk" onfocus="blurLink(this);">UCL Home</a> &#8250;&#82'
         b'50;   <a href="http://www.cs.ucl.ac.uk" onfocus="blurLink(this);">Co'
         b'mputer Science</a> &#8250;&#8250;   <a href="http://pplv.cs.ucl.ac.u'
         b'k" onfocus="blurLink(this);">PPLV Group</a>&nbsp;&#8250;&#8250;&nbsp'
         b';Research Seminars </span> </p> \r\n</div> \r\n<div class="clearing"'
         b'></div>\r\n  \r\n  <!-- End page_header slot --> \r\n  \r\n  <div id'
         b'="content">\r\n    <div id="leftcontent" class="container">   \r\n  '
         b'    \r\n<div class="lhmenu"><a href="welcome/">Welcome</a></div><d'
         b'iv class="lhmenu"><a href="people/">People</a></div><div class="lhme'
         b'nu"><a href="research_projects/">Research Projects</a></div><div cla'
         b'ss="lhmenu"><a href="phd_admissions/">PhD Admissions</a></div><div c'
         b'lass="lhmenu"><a href="msc_logic_semantics_and_verification_of_progr'
         b'ams/">MSc Logic, Semantics, and Verification of Programs</a></div><d'
         b'iv class="lhmenu">Research Seminars</div><div class="lhmenu"><a href'
         b'="news/">News</a></div>\r\n\r\n\r\n  \r\n </div> \r\n    <div id="'
         b'centercontent" class="container"> \r\n      <div id="centercontent'
         b'rhborder" class="container"> \r\n      <div id="actualcontent" cla'
         b'ss="container"> \r\n\r\n<!--TYPO3SEARCH_begin-->\r\n  <div id="c14'
         b'600" class="csc-default"><div class="csc-header csc-header-n1"><h1 c'
         b'lass="csc-firstHeader">PPLV Research Seminars</h1></div><p class="bo'
         b'dytext">The PPLV group now hosts fortnightly invited research semina'
         b'rs.</p></div><div id="c27920" class="csc-default"><p class="bodytext'
         b'">If you are interested in giving a research seminar, please contact'
         b' <a href="https://fredrikdahlqvist.wordpress.com/" title="Opens exte'
         b'rnal link in new window" target="_blank" class="external-link-new-wi'
         b'ndow">Fredrik Dahlqvist</a>&nbsp;in the first instance.</p></div><di'
         b'v id="c27919" class="csc-default"><p class="bodytext"><b>Upcoming se'
         b'minars:</b></p></div><div id="c30185" class="csc-default"><table'
         b'>\r\n<tr>\r\n<th>Time / date: </th>\r\n<td>Tuesday 11 April, 3-5pm'
         b' </td>\r\n</tr>\r\n<tr>\r\n<th>Speaker: </th>\r\n<td>Fabio Zanasi (U'
         b'CL)</td>\r\n</tr>\r\n<tr>\r\n<th>Location: </th>\r\n<td>1.20 MPEB</t'
         b'd>\r\n</tr>\r\n<tr>\r\n<th>Title: </th>\r\n<td>Formal semantics for '
         b'Bayesian reasoning</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<t'
         b'd>TBA\r\n</td>\r\n</tr>\r\n</table></div><div class="csc-default">'
         b'<div class="divider"><hr /></div></div><div id="c16021" class="csc-d'
         b'efault"><p class="bodytext"><b>Past seminars:</b></p></div><div id="'
         b'c30184" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date: </th'
         b'>\r\n<td>Tuesday 28 March, 4-5pm </td>\r\n</tr>\r\n<tr>\r\n<th>Speak'
         b'er: </th>\r\n<td>Makoto Tatsuta (National Insitute of Informatics)'
         b'</td>\r\n</tr>\r\n<tr>\r\n<th>Location: </th>\r\n<td>6.12 MPEB</'
         b'td>\r\n</tr>\r\n<tr>\r\n<th>Title: </th>\r\n<td>Equivalence of Induc'
         b'tive Definitions and Cyclic Proofs under Arithmetic</td>\r\n</tr>\r'
         b'\n<tr>\r\n<th>Abstract:</th>\r\n<td> A cyclic proof system, calle'
         b'd CLKID-omega, gives us another way of\r\nrepresenting inductive d'
         b'efinitions and efficient proof search.  The\r\n2011 paper by Broth'
         b'erston and Simpson showed that the provability of\r\nCLKID-omega i'
         b"ncludes the provability of the classical system of\r\nMartin-Lof's"
         b' inductive definitions, called LKID, and conjectured the\r\nequiva'
         b'lence.  By this year the equivalence has been left an open\r\nques'
         b'tion.  In general, the conjecture was proved to be false in\r\nFoS'
         b'SaCS 2017 paper by Berardi and Tatsuta.  However, if we restrict'
         b'\r\nboth systems to only the natural number inductive predicate an'
         b'd add\r\nPeano arithmetic to both systems, the conjecture is prove'
         b'd to be true\r\nin FoSSaCS 2017 paper by Simpson.  This talk shows'
         b' that if we add\r\narithmetic to both systems, they become equival'
         b'ent, namely, the\r\nconjecture holds.  The result of this talk inc'
         b'ludes that of the paper\r\nby Simpson as a special case.  In order'
         b' to construct a proof of LKID\r\nfor a given cyclic proof, this ta'
         b'lk shows every bud in the cyclic\r\nproof is provable in LKID, by '
         b'cutting the cyclic proof into subproofs\r\nsuch that in each subpr'
         b'oof the conclusion is a companion and the\r\nassumptions are buds.'
         b'  The global trace condition gives some induction\r\nprinciple, by'
         b' using an extension of Podelski-Rybalchenko termination\r\ntheorem'
         b' from well-foundedness to induction schema. In order to show\r\nth'
         b'is extension, this talk also shows that infinite Ramsey theorem '
         b'is\r\nformalizable in Peano arithmetic.\r\n</td>\r\n</tr>\r\n</table'
         b'></div><div class="csc-default"><div class="divider"><hr /></div></d'
         b'iv><div id="c29634" class="csc-default"><table>\r\n<tr>\r\n<th>Time '
         b'/ date: </th>\r\n<td>Tuesday 21 March, 3-5pm </td>\r\n</tr>\r\n<tr'
         b'>\r\n<th>Speaker: </th>\r\n<td>Michael Tautschnig, Queen Mary Univer'
         b'sity London</td>\r\n</tr>\r\n<tr>\r\n<th>Location: </th>\r\n<td>6.12'
         b' MPEB</td>\r\n</tr>\r\n<tr>\r\n<th>Title: </th>\r\n<td>The C Bounded'
         b' Model Checker (and how to succeed at SV-COMP)</td>\r\n</tr>\r\n<tr>'
         b'\r\n<th>Abstract:</th>\r\n<td> CBMC implements bit-precise bounded m'
         b'odel checking for C programs and has been\r\ndeveloped and maintai'
         b'ned for more than ten years.\r\n<br /><br />\r\nThe talk will start '
         b'with a hands-on tutorial on how CBMC verifies the absence of\r\nvi'
         b'olated assertions under a given loop unwinding bound by reducing the'
         b' problem\r\nto a Boolean formula. The formula is passed to a SAT s'
         b'olver, which returns a\r\nmodel if and only if the property is vio'
         b"lated.\r\n<br /><br />\r\nCBMC's support ranges from basic integer p"
         b'rograms to IEEE 754 floating point and\r\nconcurrent programs. The'
         b' tool chain around CBMC enables applications to full\r\nsoftware s'
         b'ystems, such as analysing a SAT solver and more recently has bee'
         b'n\r\napplied across the entire Debian/GNU Linux distribution.\r\n<br'
         b' /><br />\r\nMore recently, support for efficiently checking concu'
         b'rrent programs, including\r\nsupport for weak memory models, has b'
         b'een added to CBMC. At the 2017 TACAS\r\nSoftware Verification Comp'
         b'etition (SV-COMP\'17) CBMC has won the "Falsification"\r\ncategory,'
         b' making CBMC the most efficient and precise bug hunting tool.\r\n<'
         b'br /><br />\r\nBackground Reading:\r\n- https://sv-comp.sosy-lab.org'
         b'/2017/\r\n- http://cprover.org/cbmc/ (with links to various public'
         b'ations on and around\r\n  CBMC)</td>\r\n</tr>\r\n</table></div><di'
         b'v class="csc-default"><div class="divider"><hr /></div></div><div id'
         b'="c29473" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date: </'
         b'th>\r\n<td>Tuesday 7 March, 3-5pm </td>\r\n</tr>\r\n<tr>\r\n<th>Spea'
         b'ker: </th>\r\n<td>Bernardo Toninho and Raymond Hu\r\nImperial Colleg'
         b'e London</td>\r\n</tr>\r\n<tr>\r\n<th>Location: </th>\r\n<td>G.01, 6'
         b'6-72 Gower Street</td>\r\n</tr>\r\n<tr>\r\n<th>Title: </th>\r\n<td>S'
         b'ession Types and Linear Logic\r\nand\r\nLightweight Applications of '
         b'Session Types in Java</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r'
         b'\n<td> Session types is a well-established typing discipline for '
         b'message passing concurrency, originally developed in the pi-calculus'
         b' \r\nand later studied in functional and object-oriented settings.'
         b'  The first part of this talk is a tutorial on session types and its'
         b' connections \r\nto linear logic.  A recent interpretation of prop'
         b'ositions as session types for intuitionistic linear logic has been g'
         b'iven by \r\nCaires and Pfenning, viewing proofs as processes and p'
         b'roof reduction as inter-process communication.  We discuss how sever'
         b'al generalisations \r\nand extensions of this interpretation argua'
         b'bly form a basis for a logical foundation that captures several inte'
         b'resting features of \r\nmessage-passing concurrent computation.  S'
         b'pecifically, we will detail how the basic interpretation can be exte'
         b'nded to richer typed settings \r\nsuch as polymorphism and depende'
         b'nt type theories, and how to account for a notion of typed process e'
         b'quivalence that gives meaning to both \r\nproof conversions and ty'
         b'pe isomorphisms.  We will then briefly introduce the key concepts an'
         b'd intuitions behind multiparty session types (MPST).\r\n<br /> <br'
         b' /> \r\nThe second part of this talk will demonstrate Scribble, a '
         b'toolchain based on MPST, and applications in Java by using MPST to g'
         b'enerate \r\nprotocol-specific APIs for implementing distributed en'
         b'dpoints.  This practical approach builds on the linear understanding'
         b' of session types \r\nas a hybrid form of session safety: the inte'
         b'raction structure of an endpoint is captured via static Java typing,'
         b' complemented by lightweight \r\nrun-time checks on linear usage o'
         b'f channels.  Examples include Scribble specifications and Java imple'
         b'mentations of interoperable clients/servers \r\nfor standard proto'
         b'cols such as HTTP and SMTP, and Web service choreographies.  Finally'
         b', we demonstrate a recent extension of MPST with explicit \r\nconn'
         b'ection actions, that allow sessions with dynamic and optional partic'
         b'ipants.</td>\r\n</tr>\r\n</table></div><div class="csc-default"><div'
         b' class="divider"><hr /></div></div><div id="c29260" class="csc-defau'
         b'lt"><table>\r\n<tr>\r\n<th>Time / date: </th>\r\n<td>Tuesday 21 Fe'
         b'bruary, 3-5pm </td>\r\n</tr>\r\n<tr>\r\n<th>Speaker: </th>\r\n<td>Be'
         b'njamin Kaminski, Aachen University</td>\r\n</tr>\r\n<tr>\r\n<th>Lo'
         b'cation: </th>\r\n<td>Room 6.12MPEB</td>\r\n</tr>\r\n<tr>\r\n<th>Titl'
         b'e: </th>\r\n<td>A Weakest Pre-Expectation Semantics for Mixed-Sign'
         b' Expectations</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td> We'
         b' start with a short tutorial on classical weakest precondition reaso'
         b'ning \xc3\xa0 la Dijkstra and how they can be extended to weakest '
         b'pre-expectations for reasoning about expected values in probabilisti'
         b'c programs \xc3\xa0 la Kozen / McIver & Morgan. \r\n\r\nWe then pr'
         b'esent a weakest-precondition-style calculus for reasoning about expe'
         b'cted values of mixed-sign unbounded random variables after execution'
         b' of a probabilistic program. The semantics of a while-loop is well-d'
         b'efined as the limit of iteratively applying a functional to a zero-e'
         b'lement just as in the traditional weakest pre-expectation calculus, '
         b'even though a standard least fixed point argument is not applicable '
         b'in this context. A striking feature of our semantics is that it is a'
         b'lways well-defined, even if the expected values do not exist. We sho'
         b'w that the calculus is sound, allows for compositional reasoning, an'
         b'd present an invariant-based approach for reasoning about pre-expect'
         b'ations of loops.</td>\r\n</tr>\r\n</table></div><div class="csc-defa'
         b'ult"><div class="divider"><hr /></div></div><div id="c28004" class="'
         b'csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Tuesd'
         b'ay 29th November 2016, 3-4pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:'
         b'</th>\r\n<td>Jonathon Spring</td>\r\n</tr>\r\n<tr>\r\n<th>Location:<'
         b'/th>\r\n<td>6.12 Malet Place Engineering Building</td>\r\n</tr>\r'
         b'\n<tr>\r\n<th>Title:</th>\r\n<td>Why Separation Logic Works</td>\r'
         b'\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n<p>Separation Lo'
         b"gic works because it merges the software engineer's\r\nconceptual "
         b"model of a program's manipulation of computer memory\r\nwith the l"
         b'ogical model that interprets what sentences in the\r\nlogic are tr'
         b'ue. Separation Logic is an interesting case because\r\nof its wide'
         b'spread success in verification tools used by Facebook\r\nand other'
         b's daily.\r\n</p>\r\n<p>\r\nFor these two senses of model &mdash; t'
         b'he engineering/conceptual\r\nand the logical &mdash; to merge in a'
         b' genuine sense, each must maintain their\r\nnorms of use from thei'
         b'r home disciplines. When this occurs, the\r\ndevelopment of both t'
         b'he logic and engineering benefit greatly. Seeking this\r\nintersec'
         b'tion of two different senses of the concept of model provides\r\na'
         b' strategy for how computer scientists and logicians may be successfu'
         b'l.\r\nIn this talk, we will focus on an exploration of the extent '
         b'to which models merging\r\nleads to success in computer science, a'
         b'nd thereby the extent to which it is a\r\nstrategy for future deve'
         b'lopment.\r\n</p>\r\n</td>\r\n</tr>\r\n</table></div><div class="csc-'
         b'default"><div class="divider"><hr /></div></div><div id="c27918" cla'
         b'ss="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>T'
         b'hursday 17th November 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Spe'
         b'aker:</th>\r\n<td>Tyler Sorensen, Imperial College London</td>\r\n</'
         b'tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>1.02 Malet Place Engineer'
         b'ing Building</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Exposin'
         b'g Errors Related to Weak Memory in GPU Applications</td>\r\n</tr>\r'
         b'\n<tr>\r\n<th>Abstract:</th>\r\n<td> In this presentation, I will'
         b' discuss the systematic design of a\r\ntesting environment that us'
         b'es stressing and fuzzing to reveal\r\nerrors in GPU applications t'
         b'hat arise due to weak memory\r\neffects. This approach is evaluate'
         b'd across several CUDA\r\napplications that use fine-grained concur'
         b'rency, on seven GPUs\r\nspanning three Nvidia architectures. The r'
         b'esults show that\r\napplications that rarely, or never, exhibit er'
         b'rors related to\r\nweak memory when executed natively can readily '
         b'exhibit these\r\nerrors when executed in the testing environment. '
         b'The testing\r\nenvironment also provides a means to identify the r'
         b'oot causes of\r\nerroneous weak effects, and automatically suggest'
         b's how to insert\r\nfences that experimentally eliminate these erro'
         b'rs. This empirical\r\nfence insertion method carries significantly'
         b' lower overhead, in\r\nterms of execution time and energy consumpt'
         b'ion, than a more\r\nconservative, guaranteed-sound approach. Joint'
         b' work with Alastair \r\nDonaldson</td>\r\n</tr>\r\n</table></div><'
         b'div class="csc-default"><div class="divider"><hr /></div></div><div '
         b'id="c27172" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:<'
         b'/th>\r\n<td>Wednesday 13th July 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r'
         b'\n<th>Speaker:</th>\r\n<td>Letterio Galletta, University of Pisa</t'
         b'd>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>Roberts 110</td'
         b'>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Adaptivity: Linguistic '
         b'Mechanism and Static Analysis</td>\r\n</tr>\r\n<tr>\r\n<th>Abstrac'
         b't:</th>\r\n<td>\r\n  <p>Adaptive systems modify their behaviour in o'
         b'rder to run always and everywhere. Their structure is therefore subj'
         b'ect to continuous changes, which however could compromise the correc'
         b't behaviour of applications and break the guarantees on their non-fu'
         b'nctional requirements.</p>\r\n  <p>Recently, Context Oriented Prog'
         b'ramming (COP) was proposed as a viable paradigm to develop adaptive '
         b'and context-aware software. It advocates languages with peculiar con'
         b'structs that express context-dependent behaviour in a modular manner'
         b'. In this way context-awareness is built-in, and the provided lingui'
         b'stic abstractions impose a good practice to programmers.</p>\r\n  '
         b'<p>This talk introduces COP, focusing in particular on ML_CoDa, a fu'
         b'nctional context-oriented language, and its two steps static analysi'
         b's, to detect if adaptation errors may occur at run time.</p>\r\n</'
         b'td>\r\n</tr>\r\n</table></div><div class="csc-default"><div class="d'
         b'ivider"><hr /></div></div><div id="c27237" class="csc-default"><tabl'
         b'e>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Monday 27th June 2016, '
         b'4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="htt'
         b'p://www.dcs.bbk.ac.uk/~carsten/">Carsten Fuhs</a>, Birkbeck Universi'
         b'ty</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>Room 405, 66-7'
         b'2 Gower St</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>SMT Techn'
         b'iques and Solvers in Automated Termination Analysis </td>\r\n</tr>'
         b'\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n  <p>Termination is the pr'
         b'operty of a program that regardless of the input, execution of the p'
         b'rogram will always come to a halt eventually. Although this property'
         b' is undecidable, since the early 2000s fully automated techniques an'
         b'd tools for termination analysis have flourished in several communit'
         b'ies: term rewriting, imperative programs, functional programs, logic'
         b' programs, ...</p>\r\n  <p>A common theme behind most of these too'
         b'ls is the use of constraint-based techniques to advance the proof of'
         b' (non-)termination. Recently, in particular SAT and SMT solvers are '
         b'used as back-ends to automate these techniques. In my talk, I will g'
         b'ive an overview of automated termination analysis from an SMT solvin'
         b'g perspective.</p>\r\n</td>\r\n</tr>\r\n</table></div><div class="'
         b'csc-default"><div class="divider"><hr /></div></div><div id="c27234"'
         b' class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<'
         b'td>Friday 24th June 2016, 4:30-5:30pm</td>\r\n</tr>\r\n<tr>\r\n<th'
         b'>Speaker:</th>\r\n<td><a href="https://homes.cs.washington.edu/~jr'
         b'w12/">James R. Wilcox</a>, University of Washington</td>\r\n</tr>\r'
         b'\n<tr>\r\n<th>Location:</th>\r\n<td>Room 405, 66-72 Gower St</td>'
         b'\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Verdi: A Framework for I'
         b'mplementing and Verifying Distributed Systems</td>\r\n</tr>\r\n<'
         b'tr>\r\n<th>Abstract:</th>\r\n<td>\r\n  <p>Distributed systems are '
         b'difficult to implement correctly because they must handle both concu'
         b'rrency and failures. Further, their behavior is often too complex to'
         b' permit exhaustive testing. Bugs in these systems have led to the lo'
         b'ss of critical data and unacceptable service outages.</p>\r\n  <p>'
         b'We present Verdi, a framework for implementing and formally verifyin'
         b'g distributed systems in Coq. Verdi formalizes various network seman'
         b'tics with different faults, and the developer chooses the most appro'
         b'priate fault model when verifying their implementation.  Furthermore'
         b", Verdi's verified system transformers (VSTs) ease the verification "
         b'burden by enabling the developer to first verify their system under '
         b'an idealized fault model, then transfer the resulting correctness gu'
         b'arantees to a more realistic fault model without any additional proo'
         b'f burden.</p>\r\n  <p>We have used Verdi to implement and verify t'
         b'he Raft consensus protocol. We proved that our implementation of Raf'
         b't correctly provides linearizable state machine replication. This pr'
         b'oof required iteratively discovering and proving 90 system invariant'
         b's, consisting of over 50000 lines of code. At such a large scale, th'
         b'e primary challenge we faced during the verification process was pro'
         b'of maintenance. We will discuss proof engineering practices that wer'
         b'e critical to our success.</p>\r\n</td>\r\n</tr>\r\n</table></div>'
         b'<div class="csc-default"><div class="divider"><hr /></div></div><div'
         b' id="c27159" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:'
         b'</th>\r\n<td>Thursday 16th June, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>'
         b'Speaker:</th>\r\n<td><a href="http://tratt.net/laurie/">Laurence T'
         b'ratt</a>, Kings College London</td>\r\n</tr>\r\n<tr>\r\n<th>Locati'
         b'on:</th>\r\n<td>Room 405, 66-72 Gower St</td>\r\n</tr>\r\n<tr>\r\n<t'
         b'h>Title:</th>\r\n<td>Fine-grained Language Composition</td>\r\n</tr>'
         b'\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n  <p>Programming languages'
         b' are islands, each disconnected from the rest. \r\n   We choose a '
         b'language for a task and, for better or worse, stick with it. \r\n '
         b'  Communicating between programs written in different languages is s'
         b'uch a\r\n   slow, arduous, task that we avoid doing it whenever po'
         b'ssible.</p>\r\n  <p>In this talk I will first show how language co'
         b'mposition can lower, and\r\n   even remove, the barriers between l'
         b'anguages. We have pioneered new\r\n   approaches to the two major '
         b'challenges in language composition: editing\r\n   and running comp'
         b"osed programs. Using our novel editor 'Eco', users can\r\n   write"
         b' source files that contain fragments of multiple languages.  We then'
         b'\r\n   run multi-language programs using composed meta-tracing VMs'
         b'. Our\r\n   preliminary results suggest that performance of compos'
         b'ed programs is\r\n   often competitive with traditional mono-langu'
         b'age VMs.</p>\r\n  <p>Joint work with Edd Barrett, Carl Friedrich B'
         b'olz, Lukas Diekmann,\r\n   Geoff French, Sarah Mount, and Jasper S'
         b'chulz. More at <a href="http://soft-dev.org/">http://soft-dev.org/</'
         b'a></p>\r\n</td>\r\n</tr>\r\n</table></div><div class="csc-default"'
         b'><div class="divider"><hr /></div></div><div id="c27171" class="csc-'
         b'default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Thursday '
         b'9th June 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<'
         b'td><a href="http://cs.nyu.edu/~siddharth/">Siddharth Krishna</a>, Ne'
         b'w York University</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td'
         b'>6.12 Malet Place Engineering Building</td>\r\n</tr>\r\n<tr>\r\n<t'
         b'h>Title:</th>\r\n<td>Learning to Verify the Heap</td>\r\n</tr>\r\n'
         b'<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n  <p>We present a data-drive'
         b'n verification framework to automatically prove memory safety and fu'
         b'nctional correctness of heap programs. For this, we introduce a nove'
         b'l statistical machine learning technique that maps observed program '
         b'states to (possibly disjunctive) separation logic formulas describin'
         b'g the invariant shape of data structures at relevant program locatio'
         b'ns. We then attempt to verify these predictions using a theorem prov'
         b'er, where counterexamples to a predicted invariant are used as addit'
         b'ional input to the shape predictor in a refinement loop. After obtai'
         b'ning valid shape invariants, we use a second learning algorithm to s'
         b'trengthen them with data invariants, again employing a refinement lo'
         b'op using the underlying theorem prover.</p>\r\n  <p>We have implem'
         b'ented our techniques in Cricket, an extension of the GRASShopper ver'
         b'ification tool. Cricket is able to automatically prove memory safety'
         b' and correctness of implementations of a variety of classical list-m'
         b'anipulating algorithms such as insertionsort.</p>\r\n  <p>Joint wo'
         b'rk with Marc Brockschmidt, Yuxin Chen, Byron Cook, Pushmeet Kohli, D'
         b'aniel Tarlow, and He Zhu.</p>\r\n</td>\r\n</tr>\r\n<tr>\r\n<th>Biogr'
         b'aphy:</th>\r\n<td>Siddharth Krishna is a PhD student in the Comput'
         b'er Science Department of New York University, who works with Thomas '
         b'Wies. He is interested in using Machine Learning for program verific'
         b'ation and synthesis, and on using SMT and local theories to verify h'
         b'eap manipulating programs.</td>\r\n</tr>\r\n</table></div><div class'
         b'="csc-default"><div class="divider"><hr /></div></div><div id="c2622'
         b'2" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r'
         b'\n<td>Wednesday 1st June 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>S'
         b'peaker:</th>\r\n<td><a href="http://web.ist.utl.pt/nuno.lopes/">Nu'
         b'no Lopes</a>, Microsoft Research Cambridge</td>\r\n</tr>\r\n<tr>'
         b'\r\n<th>Location:</th>\r\n<td>1.03 Malet Place Engineering Building<'
         b'/td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Network Verification'
         b' at Microsoft</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>In '
         b'this talk I\xe2\x80\x99ll show why network verification is so imp'
         b'ortant today and why it will continue that way in the future. I\xe2'
         b'\x80\x99ll then survey the techniques currently used at scale by M'
         b'icrosoft, as well as new techniques being developed.</td>\r\n</tr>'
         b'\r\n</table></div><div class="csc-default"><div class="divider"><h'
         b'r /></div></div><div id="c26223" class="csc-default"><table>\r\n<t'
         b'r>\r\n<th>Time / date:</th>\r\n<td>Friday 27th May, 11am-12pm</t'
         b'd>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://www.'
         b'cs.cmu.edu/~scott/">Dana Scott</a>, Hillman University Professor of '
         b'Computer Science, Philosophy, and Mathematical Logic (Emeritus), Car'
         b'negie Mellon University</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th'
         b'>\r\n<td>Room 405, 66-72 Gower St</td>\r\n</tr>\r\n<tr>\r\n<th>Title'
         b':</th>\r\n<td>Types and Type-free Lambda Calculus</td>\r\n</tr>\r'
         b'\n<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n  <p>Denotational semantics'
         b' started in Oxford in late 1969. It was hoped that domain theory wou'
         b'ld provide a basis both for recursive definitions in programs and re'
         b'cursive definitions of semantical structures.  Early troubles were e'
         b'ncountered in using tops and bottoms, and soon researchers turned to'
         b' operational semantics. Others wanted to expand work to communicatin'
         b'g and parallel processes. Axiomatic and synthetic theories did not s'
         b'olve the problems, and as a result much research effort in domain th'
         b'eory faded.  Late work by Reynolds and collaborators, however, has o'
         b'pened up new and promising approaches for programming-language seman'
         b'tics.  Perhaps the much simplified modeling using enumeration operat'
         b'ors can spark some new investigations, especially since it is so eas'
         b'y to add a rich type structure to the calculus.</p>\r\n  <p>Video '
         b'recording: <a href="https://www.youtube.com/watch?v=QgZ8T-wEN-0">par'
         b't 1</a> &nbsp; <a href="https://www.youtube.com/watch?v=F5uQlv8Y1Qg"'
         b'>part 2</a>.</p>\r\n</td>\r\n</tr>\r\n</table></div><div class="cs'
         b'c-default"><div class="divider"><hr /></div></div><div id="c26221" c'
         b'lass="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td'
         b'>Thursday 12th May 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speake'
         b'r:</th>\r\n<td><a href="http://www.cs.bham.ac.uk/~pbl/">Paul Blain'
         b' Levy</a>, University of Birmingham</td>\r\n</tr>\r\n<tr>\r\n<th>L'
         b'ocation:</th>\r\n<td>1.02 Malet Place Engineering Building</td>\r\n<'
         b'/tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Transition Systems Over Gam'
         b'es </td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n  This '
         b'talk combines two areas of computer science.\r\n  <ul>\r\n    <li>Th'
         b'e notions of labelled transition system (a set of states, starting f'
         b'rom which an action may be performed, leading to another state), tra'
         b'ce (a possible sequence of actions from a starting state) and bisimu'
         b'lation (a relation that guarantees two states have matching behaviou'
         b'r) have provided a useful way of reasoning about computational syste'
         b'ms.</li>\r\n    <li>Game semantics is a compositional way of descr'
         b'ibing the behaviour of higher-order programs employing private state'
         b', providing a high-level description in the sense that state is not '
         b'mentioned.</li>\r\n  </ul>\r\n  <p>We want to represent game semanti'
         b'cs using transition systems, but traditional systems are too rigid b'
         b'ecause they have a fixed set of actions. So instead we develop a ver'
         b'sion of transition system in which each state sits over a position o'
         b'f our game. The actions are the currently available moves.</p>\r\n'
         b'  <p>To make this into a compositional semantics, we give a '
         b'\xe2\x80\x9ctransfer\xe2\x80\x9d, kind of program that converts mo'
         b'ves between two games, giving an operation on strategies. The agreem'
         b'ent between the transition systems and the transfer is given by a re'
         b'lation called a \xe2\x80\x9cstepped bisimulation\xe2\x80\x9d.</p>\r'
         b'\n  <p>(Joint work with Sam Staton)</p>\r\n</td>\r\n</tr>\r\n</tabl'
         b'e></div><div class="csc-default"><div class="divider"><hr /></div></'
         b'div><div id="c26220" class="csc-default"><table>\r\n<tr>\r\n<th>Time'
         b' / date:</th>\r\n<td>Wednesday 27th April 2016, 4-5pm</td>\r\n</'
         b'tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://rgrig.apps'
         b'pot.com/">Radu Grigore</a>, University of Kent</td>\r\n</tr>\r\n<tr>'
         b'\r\n<th>Location:</th>\r\n<td>Executive Suite 103, Engineering Front'
         b' Building</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Tree Buffe'
         b'rs</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>In runtime ver'
         b'ification, the central problem is to decide if a given program execu'
         b'tion violates a given property. In online runtime verification, a mo'
         b"nitor observes a program's execution as it happens. If the program b"
         b'eing observed has hard real-time constraints, then the monitor inher'
         b'its them. In the presence of hard real-time constraints it becomes a'
         b' challenge to maintain enough information to produce error traces, s'
         b'hould a property violation be observed. In this paper we introduce a'
         b' data structure, called tree buffer, that solves this problem in the'
         b' context of automata-based monitors: If the monitor itself respects '
         b'hard real-time constraints, then enriching it by tree buffers makes '
         b'it possible to provide error traces, which are essential for diagnos'
         b'ing defects. We show that tree buffers are also useful in other appl'
         b'ication domains. For example, they can be used to implement function'
         b'ality of capturing groups in regular expressions. We prove optimal a'
         b'symptotic bounds for our data structure, and validate them using emp'
         b'irical data from two sources: regular expression searching through W'
         b'ikipedia, and runtime verification of execution traces obtained from'
         b' the DaCapo test suite.</td>\r\n</tr>\r\n</table></div><div class="c'
         b'sc-default"><div class="divider"><hr /></div></div><div id="c26219" '
         b'class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<t'
         b'd>Wed 13th April 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:'
         b'</th>\r\n<td><a href="http://www.tzevelekos.org/">Nikos Tzevelekos'
         b'</a>, Queen Mary University of London</td>\r\n</tr>\r\n<tr>\r\n<th'
         b'>Location:</th>\r\n<td>Executive Suite 103, Engineering Front Buil'
         b'ding</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Model-Checking '
         b'Program Equivalence in Interface Middleweight Java </td>\r\n</tr>\r'
         b'\n<tr>\r\n<th>Abstract:</th>\r\n<td>Using game semantics, we inve'
         b'stigate the problem of verifying contextual equivalences in Interfac'
         b'e Middleweight Java (IMJ), an imperative object calculus in which pr'
         b'ogram phrases are typed using interfaces. In particular, we show how'
         b' to determine the decidability status of problem instances (over a f'
         b'ixed type signature) by examining the position of methods inside the'
         b' term type and the types of its free identifiers. Our results build '
         b'upon the recent fully abstract game semantics of IMJ. Decidability i'
         b's proved by translation into visibly pushdown register automata over'
         b' infinite alphabets with fresh-input recognition, and the procedure '
         b'has been implemented into a new tool called Coneqct. </td>\r\n</tr'
         b'>\r\n</table></div><div class="csc-default"><div class="divider"><'
         b'hr /></div></div><div id="c26218" class="csc-default"><table>\r\n<'
         b'tr>\r\n<th>Time / date:</th>\r\n<td>Thu 24th March 2016, 4-5pm</'
         b'td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://www'
         b'0.cs.ucl.ac.uk/staff/j.groth/">Jens Groth</a>, Information Security,'
         b' UCL</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>Roberts 1.10'
         b'</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Cryptography for Ea'
         b'gles</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>The talk wil'
         b'l be a high level discussion about what cryptography is and what I s'
         b'ee as important research directions. I aim to make it non-technical '
         b'and accessible for everyone and will try to leave time for discussio'
         b'n. Topics I will touch upon include multi-party computation: any eff'
         b'iciently computable function can be computed securely, i.e., the res'
         b'ult is guaranteed to be correct and private inputs remain confidenti'
         b'al, and zero-knowledge proofs: a theorem can be proved to be true wi'
         b'thout revealing anything but the fact it is true. Recently we have d'
         b'eveloped highly efficient zero-knowledge proofs; even large complex '
         b'statements have small compact proofs. Challenges: Computer-aided con'
         b'struction of cryptographic protocols and automated verification of s'
         b'ecurity proofs.</td>\r\n</tr>\r\n</table></div><div class="csc-defau'
         b'lt"><div class="divider"><hr /></div></div><div id="c25630" class="c'
         b'sc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Wed 9t'
         b'h March 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<t'
         b'd><a href="http://users.ecs.soton.ac.uk/ps/">Pawel Sobocinski</a>, U'
         b'niversity of Southampton</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</t'
         b'h>\r\n<td>1.20 MPEB</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<t'
         b'd>Graphical Linear Algebra and Applications</td>\r\n</tr>\r\n<tr'
         b'>\r\n<th>Abstract:</th>\r\n<td>I will introduce the symmetric monoid'
         b'al theory of interacting Hopf monoids, which is a string diagrammati'
         b'c language capable of capturing most standard concepts of finite-dim'
         b'ensional linear algebra. I will briefly outline recent work on appli'
         b'cations to signal flow graphs, a classical formalism in control theo'
         b'ry and signal processing. Various results in the talk are the result'
         b' of joint work with Filippo Bonchi and Fabio Zanasi, and with Brenda'
         b'n Fong and Paolo Rapisarda. I have been blogging about graphical lin'
         b'ear algebra at <a href="http://graphicallinearalgebra.net">http://gr'
         b'aphicallinearalgebra.net</a></td>\r\n</tr>\r\n</table></div><div cla'
         b'ss="csc-default"><div class="divider"><hr /></div></div><div id="c27'
         b'541" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th'
         b'>\r\n<td>Fri 26th February 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>'
         b'Speaker:</th>\r\n<td><a href="http://www.anupamdas.com/">Anupam Da'
         b's</a>, ENS de Lyon</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<t'
         b'd>Roberts 110 </td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>An in'
         b'troduction to linear rewriting in propositional logic </td>\r\n</t'
         b'r>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>Linear term rewriting can '
         b'be an effective way to control space complexity in the computation o'
         b'f normal forms, deciding reachability etc. They are also fundamental'
         b' in proof theory, controlling the logical behaviour of a system when'
         b' formulated with multiplicative rules. This research line begins wit'
         b'h the observation that entailment between linear terms of Boolean al'
         b'gebras is already coNP-complete, i.e. all propositional tautologies '
         b"can be written as a 'linear inference'. I will present some characte"
         b'risations of various subsystems as well as certain negative results,'
         b' culminating in a recent result that there is no complete basis of l'
         b'inear rules. The proofs in this area are often simple and elegant on'
         b'ce appropriate invariants are identified; this itself relies on a co'
         b'mbination of tools from term rewriting, graph theory and Boolean fun'
         b'ction theory. Finally I present an abstraction of linear terms in a '
         b'graph-theoretic setting and discuss some ongoing work where reductio'
         b'n behaviour is more well-behaved, but where we are forced to leave t'
         b'he world of Boolean functions altogether. This will be a low-level a'
         b'nd first-principles talk and should be accessible to all!</td>\r\n'
         b'</tr>\r\n</table></div><div class="csc-default"><div class="divide'
         b'r"><hr /></div></div><div id="c27543" class="csc-default"><table'
         b'>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Wed 24th Feb 2016, 4-5pm'
         b'</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://w'
         b'ww.cs.rhul.ac.uk/home/hague/">Matthew Hague</a>, Royal Holloway, Uni'
         b'versity of London</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td'
         b'>Roberts 422</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Logic, '
         b'Automata, and Types at Higher Orders</td>\r\n</tr>\r\n<tr>\r\n<th>'
         b'Abstract:</th>\r\n<td>The equivalence of alternating parity tree a'
         b'utomata, the modal mu-calculus, and parity games as definitional dev'
         b'ices for tree languages is a keystone result underpinning the model '
         b'checking of reactive systems. In this talk, we lift this equi-expres'
         b'sivity result to languages of higher-type Bohm trees, which may be v'
         b'iewed as higher-order functions over trees.<br /><br />We equip Stir'
         b"ling's alternating dependency tree automata (ADTA) with an omega-reg"
         b'ular winning condition, and show that they are equi-expressive with '
         b'Kobayashi-Ong intersection types for defining languages of infinite '
         b'Bohm trees. We then introduce higher-type mu-calculus, which extends'
         b' mu-calculus with predicates for detecting variables, and correspond'
         b'ing constructs for detecting lambda-abstractions. We show that highe'
         b'r-type mu-calculus is equi-expressive with a subclass of intersectio'
         b'n types (equivalently, ADTA) called parity permissive. We conjecture'
         b' that parity permissive restricts the expressive power of intersecti'
         b'on types and ADTA.</td>\r\n</tr>\r\n</table></div><div class="csc-de'
         b'fault"><div class="divider"><hr /></div></div><div id="c27545" class'
         b'="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Wed'
         b' 10th February 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</'
         b'th>\r\n<td><a href="http://www.cs.bham.ac.uk/~drg/">Dan Ghica</a>,'
         b' University of Birmingham</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</'
         b'th>\r\n<td>1.02 MPEB</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<'
         b'td>Alpha equivalence for interleaved scopes</td>\r\n</tr>\r\n<tr'
         b'>\r\n<th>Abstract:</th>\r\n<td>I will describe the key syntactic and'
         b' semantic aspects of a nominal framework allowing scopes of name bin'
         b'dings to be arbitrarily interleaved. Name binding (e.g. delta x.M) i'
         b's handled by explicit name-creation and name-destruction brackets wh'
         b'ich admit interleaving. We will see an appropriate notion of alpha-e'
         b'quivalence for such a language and study the syntactic structure req'
         b'uired for alpha-equivalence to be a congruence. I will sketch some p'
         b'otential applications to semantics of programming languages with exp'
         b'licit resource allocation and release. This is joint work with James'
         b' Gabbay and Daniela Petrisan.</td>\r\n</tr>\r\n</table></div><div cl'
         b'ass="csc-default"><div class="divider"><hr /></div></div><div id="c2'
         b'7547" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</t'
         b'h>\r\n<td>Thu 28th January 2016, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>'
         b'Speaker:</th>\r\n<td>Jonathan Spring, PPLV/Information Security, U'
         b'CL</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>Roberts 110</t'
         b'd>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Avoiding Pseudoscience'
         b': Prudence, Logic, and Verification in Studying Information Security'
         b'</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>Pseudoscience is'
         b' a (pejorative) term for some pursuit that is judged not to be scien'
         b'ce but whose participants lay claim to the respectability of science'
         b" regardless. In this talk I'll discuss how we might judge whether so"
         b'me pursuit is (pseudo)science and how we might verify whether some s'
         b'ample work in information security passes this judgement. The result'
         b' is a rough framework for improving work in computer science work su'
         b'ch as program verification and information security.</td>\r\n</tr>'
         b'\r\n</table></div><div class="csc-default"><div class="divider"><h'
         b'r /></div></div><div id="c27549" class="csc-default"><table>\r\n<t'
         b'r>\r\n<th>Time / date:</th>\r\n<td>Fri 11th December 2015, 4-5pm</td'
         b'>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://www.d'
         b'cs.bbk.ac.uk/~carsten/">Carsten Fuhs</a>, Birkbeck</td>\r\n</tr>\r\n'
         b'<tr>\r\n<th>Location:</th>\r\n<td>6.12 MPEB (Malet Place Engineering'
         b' Building)</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Automatic'
         b' Quantitative Resource Analysis for Programs</td>\r\n</tr>\r\n<t'
         b'r>\r\n<th>Abstract:</th>\r\n<td>We present a modular approach to aut'
         b'omatic resource complexity analysis of integer programs. Based on a '
         b'novel alternation between finding symbolic time bounds for program p'
         b'arts and using these to infer bounds on the absolute values of progr'
         b'am variables, we can restrict each analysis step to a small part of '
         b'the program while maintaining a high level of precision. The resourc'
         b'e bounds computed by our method are polynomial or exponential expres'
         b'sions that depend on the absolute values of input parameters. Our co'
         b'ntributions are implemented in the open-source tool KoAT, and extens'
         b'ive experiments show the performance and power of our implementation'
         b' in comparison with other tools.</td>\r\n</tr>\r\n</table></div><div'
         b' class="csc-default"><div class="divider"><hr /></div></div><div id='
         b'"c27551" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th'
         b'>\r\n<td>Wed 25th November 2015, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>'
         b'Speaker:</th>\r\n<td><a href="http://www.cs.umd.edu/~awruef/">Andr'
         b'ew Ruef</a>, University of Maryland</td>\r\n</tr>\r\n<tr>\r\n<th>L'
         b'ocation:</th>\r\n<td>6.12 MPEB (Malet Place Engineering Building)<'
         b'/td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Creating Industrial '
         b'Software Analysis Systems or How I Learned to Stop Worrying and Just'
         b' Smush Fuzzers and Symbolic Executors Together</td>\r\n</tr>\r\n<tr>'
         b'\r\n<th>Abstract:</th>\r\n<td>Software fails us every day and we wan'
         b't it to stop. Absent a magical wand to rid the world of legacy code,'
         b' something should be done to find bugs in C programs so that someone'
         b' can fix them. We have existing tools and techniques but how can we '
         b'apply them to real code at scale and get results? In this talk, '
         b'I\xe2\x80\x99ll explore our efforts at creating systems that comb'
         b'ine fuzzing, symbolic execution, and abstract interpretation, and di'
         b'scuss our results in finding memory corruption bugs in a somewhat co'
         b'ntrolled experiment. I\xe2\x80\x99ll also talk about benefits and'
         b' challenges of \xe2\x80\x9cindustrial grade\xe2\x80\x9d system dev'
         b'elopment and some of the theoretical ideas and future directions in '
         b'combining information generated by analyzers using counterexample gu'
         b'ided abstraction refinement.</td>\r\n</tr>\r\n</table></div><div cla'
         b'ss="csc-default"><div class="divider"><hr /></div></div><div id="c27'
         b'921" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th'
         b'>\r\n<td>Fri 20th November 2015, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>'
         b'Speaker:</th>\r\n<td><a href="https://www8.cs.fau.de/milius">Stefa'
         b'n Milius</a>, FAU Erlangen-N&uuml;rnberg</td>\r\n</tr>\r\n<tr>\r\n'
         b'<th>Location:</th>\r\n<td>1.19 MPEB (Malet Place Engineering Build'
         b'ing)</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Formal Verifica'
         b'tion of Systems of Synchronous Software Components</td>\r\n</tr>\r\n'
         b'<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n<p>Software of distributed, '
         b'safety-critical embedded systems, as e.g. found in the automotive, r'
         b'ailway or avionics domain, has to satisfy very high requirements con'
         b'cerning correctness and fault tolerance. Therefore standards for the'
         b' development of such systems highly recommend the usage of formal me'
         b'thods. For many complex control tasks the preferred architecture is '
         b'a system composed from components that operate synchronously but com'
         b'municate asynchronously with other components &ndash; a paradigm cal'
         b'led GALS (globally asynchronous &ndash; locally synchronous) archite'
         b'cture.</p>\r\n<p>In this talk we present an approach to close the '
         b'&quot;methodological&quot; gap between the formal verification of sy'
         b'nchronous components and asynchronous system of components. We mainl'
         b'y focus on systems where the synchronous components are implemented '
         b'in SCADE (a language and modelling tool for synchronous controller s'
         b'oftware). The idea is then to abstract such concrete components with'
         b' contracts, which are a mixture of temporal logic formulas and non-d'
         b'eterministic state machines. Formal verification of global system pr'
         b'operties is then done on a network of contracts that has a lower com'
         b'plexity than the original network of concrete components. We will fi'
         b'rst explain the verification approach in general. Then we introduce '
         b'a modelling language for the specification of contracts, and we then'
         b' explain the transformations used for model checking GALS systems. O'
         b'ur model checking method is based on bounded model checking using SA'
         b'T and SMT solvers. Finally, we demonstrate the results of our approa'
         b'ch and tool on an industrial case study.</p>\r\n</td>\r\n</tr>\r\n'
         b'</table></div><div class="csc-default"><div class="divider"><hr /></'
         b'div></div><div id="c27923" class="csc-default"><table>\r\n<tr>\r\n<t'
         b'h>Time / date:</th>\r\n<td> Wed 21st October 2015, 4-5pm</td>\r\n</t'
         b'r>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="https://www.kent.a'
         b'c.uk/secl/philosophy/staff/williamson.html">Jon Williamson</a>, Univ'
         b'ersity of Kent</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>1.'
         b'04 MPEB (Malet Place Engineering Building)</td>\r\n</tr>\r\n<tr>'
         b'\r\n<th>Title:</th>\r\n<td>Inductive Logic for Automated Decision Ma'
         b'king</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>According to'
         b" Bayesian decision theory, one's acts should maximise expected utili"
         b'ty. To calculate expected utility one needs not only the utility of '
         b'each act in each possible scenario but also the probabilities of the'
         b' various scenarios. It is the job of an inductive logic to determine'
         b' these probabilities, given the evidence to hand. The most natural i'
         b'nductive logic, classical inductive logic, attributable to Wittgenst'
         b'ein, was dismissed by Carnap due to its apparent inability to captur'
         b'e the phenomenon of learning from experience. I argue that Carnap wa'
         b's too hasty to dismiss this logic: classical inductive logic can be '
         b'rehabilitated, and the problem of learning from experience overcome,'
         b' by appealing to the principles of objective Bayesianism. I then dis'
         b'cuss the practical question of how to calculate the required probabi'
         b'lities and show that the machinery of probabilistic networks can be '
         b'fruitfully applied here. This culminates in an objective Bayesian de'
         b'cision theory that has a realistic prospect of automation.</td>\r'
         b'\n</tr>\r\n</table></div><div class="csc-default"><div class="divid'
         b'er"><hr /></div></div><div id="c24964" class="csc-default">\n'
         b'\t\t\t\t<table class="contenttable contenttable-0">\n\t\t\t\t\t<tr'
         b' class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" i'
         b'd="row24964-0">Time / date: </th>\n\t\t\t\t\t\t\t<td class="td-1" he'
         b'aders="row24964-0"> Fri 9th October 2015, 4-5pm </td>\n\t\t\t\t\t\t'
         b'\t<td class="td-last td-2" headers="row24964-0"> </td>\n\t\t\t\t\t<'
         b'/tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t<th class='
         b'"td-0" scope="row" id="row24964-1">Speaker: </th>\n\t\t\t\t\t\t\t<td'
         b' class="td-1" headers="row24964-1"> Sukriti Bhattacharya, PPLV, UCL '
         b'</td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row24964-1"> '
         b'</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row24964-2">Location'
         b': </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row24964-2"> 6.12 M'
         b'PEB (Malet Place Engineering Building) </td>\n\t\t\t\t\t\t\t<td clas'
         b's="td-last td-2" headers="row24964-2"> </td>\n\t\t\t\t\t</tr>\n'
         b'\t\t\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0'
         b'" scope="row" id="row24964-3">Title: </th>\n\t\t\t\t\t\t\t<td class='
         b'"td-1" headers="row24964-3"> MaDSLaM: A Statistical Language Model F'
         b'or Malware Detection </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" h'
         b'eaders="row24964-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr'
         b'-even tr-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row2'
         b'4964-4">Abstract: </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row'
         b'24964-4"> Malware continues to be an ongoing threat to modern comput'
         b'ing. The detection of malware is an area of major concern not only t'
         b'o the research community but also to the general public. We introduc'
         b'e MaDSLaM, a framework for enabling statistical analysis on binary e'
         b'xecutables by filtering out malicious executables at the early stage'
         b' of malware analysis phase with a sufficiently low false positive ra'
         b'te. MaDSLaM exploits the naturalness of software via natural languag'
         b'e processing techniques by building language models that distinguish'
         b' between malware and benign files at the executable binary level. We'
         b' developed a proof-of-concept version of MaDSLaM and evaluated it ov'
         b'er a fairly large set of malware samples cover a wide range of malwa'
         b're families and malware authors. </td>\n\t\t\t\t\t\t\t<td class="td-'
         b'last td-2" headers="row24964-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</'
         b'table></div><div class="csc-default"><div class="divider"><hr /></di'
         b'v></div><div id="c27929" class="csc-default"><table>\r\n<tr>\r\n<th>'
         b'Time / date:</th>\r\n<td>Fri 5th June 2015, 4-5pm</td>\r\n</tr>\r'
         b'\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://www.cs.rhul.ac'
         b'.uk/home/kinder/">Johannes Kinder</a>, Royal Holloway, University of'
         b' London</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>6.12 MPEB'
         b'</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>High System-Code Se'
         b'curity with Low Overhead</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</t'
         b'h>\r\n<td>\r\n<p>Security vulnerabilities plague modern systems beca'
         b'use writing secure systems code is hard. Promising approaches can re'
         b'trofit security automatically via runtime checks that implement the '
         b'desired security policy; these checks guard critical operations, lik'
         b'e memory accesses. Alas, the induced slowdown usually exceeds by a w'
         b'ide margin what system users are willing to tolerate in production, '
         b'so these tools are hardly ever used. As a result, the insecurity of '
         b'real-world systems persists. We present an approach in which develop'
         b'ers/operators can specify what level of overhead they find acceptabl'
         b'e for a given workload (e.g., 5%); our proposed tool ASAP then autom'
         b'atically instruments the program to maximize its security while stay'
         b'ing within the specified "overhead budget." Two insights make this a'
         b'pproach effective: most overhead in existing tools is due to only a '
         b'few "hot" checks, whereas the checks most useful to security are typ'
         b'ically "cold"and cheap. We evaluate ASAP on programs from the Phoron'
         b'ix and SPEC benchmark suites. It can precisely select the best point'
         b's in the security-performance spectrum. Moreover, we analyzed existi'
         b'ng bugs and security vulnerabilities in RIPE, OpenSSL, and the Pytho'
         b'n interpreter, and found that the protection level offered by the AS'
         b'AP approach is sufficient to protect against all of them.</p>\r\n<'
         b'p>Joint work with Jonas Wagner, Volodymyr Kuznetsov and George Cande'
         b'a (EPFL), presented at IEEE S&P (Oakland) 2015.</p>\r\n</td>\r\n</tr'
         b'>\r\n</table></div><div class="csc-default"><div class="divider"><'
         b'hr /></div></div><div id="c27930" class="csc-default"><table>\r\n<'
         b'tr>\r\n<th>Time / date:</th>\r\n<td>Fri 8th May 2015, 4-5pm</td>'
         b'\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://www0.c'
         b's.ucl.ac.uk/people/M.Kanovich.html">Max Kanovich</a>, PPLV, UCL</td>'
         b'\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>1.04 MPEB</td>\r\n<'
         b'/tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Discrete vs. Dense Times in'
         b' the Analysis of Cyber-Physical Security Protocols</td>\r\n</tr>\r\n'
         b'<tr>\r\n<th>Abstract:</th>\r\n<td>Many security protocols rely on th'
         b'e assumptions on the physical properties in which its protocol sessi'
         b'ons will be carried out. For instance, Distance Bounding Protocols t'
         b'ake into account the round trip time of messages and the transmissio'
         b'n velocity to infer an upper bound of the distance between two agent'
         b's. We classify such security protocols as Cyber-Physical. Time plays'
         b' a key role in design and analysis of many of these protocols. This '
         b'work investigates the foundational differences and the impacts on th'
         b'e analysis when using models with discrete time and models with dens'
         b'e time. We show that there are attacks that can be found by models u'
         b'sing dense time, but not when using discrete time. We illustrate thi'
         b's with a novel attack that can be carried out on most distance bound'
         b'ing protocols. In this attack, one exploits the execution delay of i'
         b'nstructions during one clock cycle to convince a verifier that he is'
         b' in a location different from his actual position. We propose a Mult'
         b'iset Rewriting model with dense time suitable for specifying cyber-p'
         b'hysical security protocols. We introduce Circle-Configurations and s'
         b'how that they can be used to symbolically solve the reachability pro'
         b'blem for our model. Finally, we show that for the important class of'
         b' balanced theories the reachability problem is PSPACE-complete.</td>'
         b'\r\n</tr>\r\n</table></div><div class="csc-default"><div class="divi'
         b'der"><hr /></div></div><div id="c27932" class="csc-default"><tab'
         b'le>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Fri 24th April 2015, 4'
         b'-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http'
         b'://www-users.cs.york.ac.uk/~miked/">Mike Dodds</a>, University of Yo'
         b'rk</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>6.12 MPEB</td>'
         b'\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>A Scalable, Correct Time'
         b'-Stamped Stack</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td><p'
         b'>Concurrent data-structures, such as stacks, queues, and deques, oft'
         b'en implicitly enforce a total order over elements in their underlyin'
         b'g memory layout. However, much of this order is unnecessary: lineari'
         b'zability only requires that elements are ordered if the insert metho'
         b'ds ran in sequence. We propose a new approach which uses timestampin'
         b'g to avoid unnecessary ordering. Pairs of elements can be left unord'
         b'ered if their associated insert operations ran concurrently, and ord'
         b'er imposed as necessary at the eventual removal.</p>\r\n<p>We real'
         b'ise our approach in a new non-blocking data structure, the TS (times'
         b'tamped) stack. Using the same approach, we can define corresponding '
         b'queue and deque datastructures. In experiments on x86, the TS stack '
         b'outperforms and outscales all its competitors \xe2\x80\x93 for ex'
         b'ample, it outperforms the elimination-backoff stack by factor of two'
         b'. In our approach, more concurrency translates into less ordering, g'
         b'iving less-contended removal and thus higher performance and scalabi'
         b'lity. Despite this, the TS stack is linearizable with respect to sta'
         b'ck semantics.</p>\r\n<p>The weak internal ordering in the TS stack'
         b' presents a challenge when establishing linearizability: standard te'
         b'chniques such as linearization points work well when there exists a '
         b'total internal order. We present a new stack theorem, mechanised in '
         b'Isabelle, which characterises the orderings sufficient to establish '
         b'stack semantics. By applying our stack theorem, we show that the TS '
         b'stack is indeed linearizable. Our theorem constitutes a new, generic'
         b' proof technique for concurrent stacks, and it paves the way for fut'
         b'ure weakly ordered data-structure designs.</p>\r\n<p>Associated pa'
         b'per: <a href="http://www-users.cs.york.ac.uk/~miked/publications/POP'
         b'L.15.ts_stack.pdf">http://www-users.cs.york.ac.uk/~miked/publication'
         b's/POPL.15.ts_stack.pdf</a></p>\r\n</td>\r\n</tr>\r\n</table></div>'
         b'<div class="csc-default"><div class="divider"><hr /></div></div><div'
         b' id="c27934" class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:'
         b'</th>\r\n<td>Fri 10th April 2015, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th'
         b'>Speaker:</th>\r\n<td><a href="http://www.doc.ic.ac.uk/~azalea/">A'
         b'zalea Raad</a>, Imperial College London</td>\r\n</tr>\r\n<tr>\r\n<'
         b'th>Location:</th>\r\n<td>6.12 MPEB</td>\r\n</tr>\r\n<tr>\r\n<th>Titl'
         b'e:</th>\r\n<td>CoLoSL: Concurrent Local Subjective Logic</td>\r\n</t'
         b'r>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>A key difficulty in verify'
         b'ing shared-memory concurrent programs is reasoning compositionally a'
         b'bout each thread in isolation. Existing verification techniques for '
         b'fine-grained concurrency require reasoning about static global share'
         b'd resource, impeding compositionality. This work introduces the prog'
         b'ram logic of CoLoSL, where each thread is verified with respect to i'
         b'ts subjective view of the global shared state. This subjective view '
         b'describes only that part of the global shared resource accessed by t'
         b'he thread. Subjective views may arbitrarily overlap with each other,'
         b' and expand and contract depending on the resource required by the t'
         b'hread. This flexibility provides truly compositional proofs for shar'
         b'ed-memory concurrency, which we demonstrate on a range of examples i'
         b'ncluding a concurrent computation of a spanning tree of a graph.</td'
         b'>\r\n</tr>\r\n</table></div><div class="csc-default"><div class="div'
         b'ider"><hr /></div></div><div id="c27936" class="csc-default"><table>'
         b'\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Thu 9th April 2015, 4-5pm'
         b'</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://u'
         b'sers.cecs.anu.edu.au/~zhehou/">Zh&eacute; H&oacute;u</a>, Australian'
         b' National University, Canberra</td>\r\n</tr>\r\n<tr>\r\n<th>Locati'
         b'on:</th>\r\n<td>6.12 MPEB</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</t'
         b'h>\r\n<td>Labelled Sequent Calculi and Automated Reasoning for Ass'
         b'ertions in Separation Logic</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:'
         b'</th>\r\n<td>Separation Logic (SL) is an extension of Hoare Logic '
         b'to reason about programs with mutable data structures. We start by l'
         b'ooking at the abstract core of the assertion language of SL, namely '
         b'Boolean BI (BBI). We give a sound, complete, and cut-eliminable labe'
         b'lled sequent calculus for BBI, then we consider proof search using o'
         b'ur calculus. Next we extend our method to capture BBI with various e'
         b'xtra properties (a.k.a. separation theories) that are useful in memo'
         b'ry/heap models. We show that our labelled calculi can handle BBI wit'
         b'h any subset of separation theories. This results in a modular theor'
         b'em prover for BBI with separation theories. Finally, we move to SL w'
         b"ith concrete heap model, a la Reynolds, O'Hearn, Calcagno, Yang etc."
         b'. We give extensions of our calculi with rules for heaps and data st'
         b'ructures. Our method handles all the logical connectives in separati'
         b'on logic, and resolves some problems in the literature, too.</td'
         b'>\r\n</tr>\r\n</table></div><div class="csc-default"><div class="div'
         b'ider"><hr /></div></div><div id="c27938" class="csc-default"><table>'
         b'\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Fri 20th March 2015, 4-5p'
         b'm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://'
         b'cas.ee.ic.ac.uk/people/fw1811/">Felix Winterstein</a>, Imperial Coll'
         b'ege London</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>1.20 M'
         b'alet Place Engineering Building (MPEB)</td>\r\n</tr>\r\n<tr>\r\n<t'
         b'h>Title:</th>\r\n<td>Separation Logic-Assisted Code Transformation'
         b's for Efficient High-Level Synthesis</td>\r\n</tr>\r\n<tr>\r\n<th>'
         b'Abstract:</th>\r\n<td>The capabilities of modern FPGAs permit the '
         b'mapping of increasingly complex applications into reconfigurable har'
         b'dware. High-level synthesis (HLS) promises a significant shortening '
         b'of the FPGA design cycle by raising the abstraction level of the des'
         b'ign entry to high-level languages such as C/C++. Applications using '
         b'dynamic, pointer-based data structures and dynamic memory allocation'
         b', however, remain difficult to implement well, yet such constructs a'
         b're widely used in software. Automated optimizations that aim to leve'
         b'rage the increased memory bandwidth of FPGAs by distributing the app'
         b'lication data over separate banks of on-chip memory are often ineffe'
         b'ctive in the presence of dynamic data structures, due to the lack of'
         b' an automated analysis of pointer-based memory accesses. In this wor'
         b'k, we take a step towards closing this gap. We present a static anal'
         b'ysis for pointer-manipulating programs which automatically splits he'
         b'ap-allocated data structures into disjoint, independent regions. The'
         b' analysis leverages recent advances in separation logic, a theoretic'
         b'al framework for reasoning about heap-allocated data which has been '
         b'successfully applied in recent software verification tools. Our algo'
         b'rithm focuses on dynamic data structures accessed in loops and is ac'
         b'companied by automated source-to-source transformations which enable'
         b' automatic loop parallelization and memory partitioning by off-the-s'
         b'helf HLS tools. We demonstrate the successful loop parallelization a'
         b'nd memory partitioning by our tool flow using three real-life applic'
         b'ations which build, traverse, update and dispose dynamically allocat'
         b'ed data structures. Our case studies, comparing the automatically pa'
         b'rallelized to the direct HLS implementations, show an average latenc'
         b'y reduction by a factor of 2.5 across our benchmarks.</td>\r\n</tr'
         b'>\r\n</table></div><div class="csc-default"><div class="divider"><'
         b'hr /></div></div><div id="c27940" class="csc-default"><table>\r\n<'
         b'tr>\r\n<th>Time / date:</th>\r\n<td>Fri 6th March 2015, 4-5pm</t'
         b'd>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://www0'
         b'.cs.ucl.ac.uk/people/Gabrielle.Anderson.html">Gabrielle Anderson</a>'
         b', PPLV, UCL</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>309 R'
         b'oberts Building</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>Defe'
         b'asible Reasoning in a Sequent Calculus</td>\r\n</tr>\r\n<tr>\r\n<t'
         b'h>Abstract:</th>\r\n<td>When abstract models of argumentation are '
         b'combined with accounts of the structure of arguments, two lines of r'
         b'esearch have emerged. In one, there is an attempt to reduce defeasib'
         b'le reasoning to inconsistency handling in classical logic; in the ot'
         b'her, there are several approaches to modelling commmon-sense reasoni'
         b'ng using a combination of strict and defeasible rules, notably ASPIC'
         b'+. In this work, we show how simple rules of knowledge representatio'
         b'n, and of a sequent calculus for a logic handling levels of defeasib'
         b'le reasoning, can overcome the divisions among these lines by provin'
         b'g that they (1) encompass ASPIC+ formalisation of arguments and (2) '
         b'respect the rationality postulates for argumentation reasoning.</td>'
         b'\r\n</tr>\r\n</table></div><div class="csc-default"><div class="divi'
         b'der"><hr /></div></div><div id="c27942" class="csc-default"><tab'
         b'le>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Fri 6th February 2015,'
         b' 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td>Tyler Soren'
         b'sen, PPLV, University College London</td>\r\n</tr>\r\n<tr>\r\n<th>'
         b'Location:</th>\r\n<td>1.20 Malet Place Engineering Building (MPEB)'
         b'</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r\n<td>GPU concurrency: We'
         b'ak behaviours and programming assumptions</td>\r\n</tr>\r\n<tr>\r'
         b'\n<th>Abstract:</th>\r\n<td>\r\n<p>Concurrency is pervasive and p'
         b'erplexing, particularly on graphics processing units (GPUs). Current'
         b' specifications of languages and hardware are inconclusive; thus pro'
         b'grammers often rely on folklore assumptions when writing software. T'
         b'o remedy this state of affairs, we conducted a large empirical study'
         b' of the concurrent behaviour of deployed GPUs. Armed with litmus tes'
         b'ts (i.e. short concurrent programs), we questioned the assumptions i'
         b'n programming guides and vendor documentation about the guarantees p'
         b'rovided by hardware. We developed a tool to generate thousands of li'
         b'tmus tests and run them under stressful workloads. We observed a lit'
         b'any of previously elusive weak behaviours, and exposed folklore beli'
         b'efs about GPU programming&mdash;often supported by official tutorial'
         b's&mdash;as false.</p>\r\n<p>As a way forward, we propose a model o'
         b'f Nvidia GPU hardware, which correctly models every behaviour witnes'
         b'sed in our experiments. The model is a variant of SPARC Relaxed Memo'
         b'ry Order (RMO), structured following the GPU concurrency hierarchy.<'
         b'/p>\r\n</td>\r\n</tr>\r\n</table></div><div class="csc-default"><d'
         b'iv class="divider"><hr /></div></div><div id="c27944" class="csc-def'
         b'ault"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Fri 23rd Jan'
         b'uary 2015, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><'
         b'a href="http://www.doc.ic.ac.uk/~nyc04/">Nathan Chong</a>, PPLV, Uni'
         b'versity College London</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>'
         b'\r\n<td>508 Roberts Building</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th'
         b'>\r\n<td>Scalable Verification Techniques for Data-Parallel Progra'
         b'ms</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n<p>Verif'
         b'ication techniques that can scale to reasoning about real, rather th'
         b'an synthetic or toy, programs are essential for practical program ve'
         b'rifiers. GPUVerify is a verification tool, built at MSR and Imperial'
         b', to reason about data-parallel programs. In particular, massively-p'
         b'arallel Graphics Processing Unit (GPU) programs. In this domain we h'
         b'ave explored different characteristics of scalability: verifier prec'
         b'ision, performance and automation.</p>\r\n<p>After covering the co'
         b're verification method that enables GPUVerify to scale to realistic '
         b'problem sizes, I will talk about:</p>\r\n<ol>\r\n  <li value="1">An '
         b'empirical study of candidate-based invariant generation exploring th'
         b'e trade-offs between precision and performance.</li>\r\n  <li valu'
         b'e="2">Barrier invariants: an abstraction for precise and scalable re'
         b'asoning about data-dependent GPU programs.</li>\r\n</ol>\r\n</td'
         b'>\r\n</tr>\r\n</table></div><div class="csc-default"><div class="div'
         b'ider"><hr /></div></div><div id="c27946" class="csc-default"><table>'
         b'\r\n<tr>\r\n<th>Time / date:</th>\r\n<td>Fri 12th December 2014, 4'
         b'-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http'
         b'://daniellustig.net/">Daniel Lustig</a>, Princeton University</t'
         b'd>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>6.12 Malet Place En'
         b'gineering Building (MPEB)</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>'
         b'\r\n<td>Checking microarchitectural implementations of weak memory'
         b'</td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n<p>In para'
         b'llel programs, threads communicate according to the memory consisten'
         b'cy model: the set of memory ordering rules enforced by a given archi'
         b'tecture. A great deal of research effort has gone into rigorous form'
         b'alization of memory models. However, comparatively little attention '
         b'has been paid to the microarchitectural implementation of these mode'
         b'ls. Standard testing-based techniques are insufficient: unobserved b'
         b'ehaviors are not guarantees of non-observability, and failed tests o'
         b'ffer little insight into the microarchitectural reason behind failur'
         b'e.</p>\r\n<p>I will present PipeCheck, a methodology and automated'
         b' tool for verifying that a given microarchitecture correctly impleme'
         b'nts the memory consistency model specified by its architectural spec'
         b'ification. PipeCheck adapts the formal notion of a "happens before" '
         b'graph to the microarchitecture space. Architectural specifications s'
         b'uch as preserved program order are then treated as propositions to b'
         b'e verified, rather than simply as assumptions. We also specify and a'
         b'nalyze the behavior of common microarchitectural optimizations such '
         b'as speculative load reordering. Using PipeCheck, we were able to val'
         b'idate the OpenSPARC T2 in just minutes, and we found and fixed a bug'
         b' in a architectural simulator widely used in academia.PipeCheck has '
         b'been nominated for the Best Paper award at MICRO 2014, to be held in'
         b' Cambridge, UK this December. At the end, I will also briefly introd'
         b'uce ArMOR, a framework for defining dynamic binary translation layer'
         b's that seamlessly translate between memory consistency models such a'
         b's those used by x86, ARM, and Power.</p>\r\n<p>Bio: Daniel Lustig '
         b'is a PhD candidate in Electrical Engineering at Princeton University'
         b'. His research interests lie in the field of computer architecture, '
         b'with a particular emphasis on designing memory systems for heterogen'
         b'eous architectures. His recent work focuses verification of microarc'
         b'hitectural implementations of memory consistency models. Daniel earn'
         b'ed his BSE from the University of Pennsylvania in 2009 and his MA fr'
         b'om Princeton University in 2011. He also received an Intel PhD Fello'
         b'wship in 2013.</p>\r\n</t>\r\n</tr>\r\n</table></div><div class="c'
         b'sc-default"><div class="divider"><hr /></div></div><div id="c27948" '
         b'class="csc-default"><table>\r\n<tr>\r\n<th>Time / date:</th>\r\n<t'
         b'd>Wed 26th November 2014, 4-5pm</td>\r\n</tr>\r\n<tr>\r\n<th>Speak'
         b'er:</th>\r\n<td><a href="http://srg.doc.ic.ac.uk/people/hristina-p'
         b'alikareva/">Hristina Palikareva</a>, Imperial College London</td'
         b'>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>1.20 Malet Place Eng'
         b'ineering Building (MPEB)</td>\r\n</tr>\r\n<tr>\r\n<th>Title:</th>\r'
         b'\n<td>Constraint Solving in Symbolic Execution</td>\r\n</tr>\r\n<'
         b'tr>\r\n<th>Abstract:</th>\r\n<td>\r\n<p>Dynamic symbolic execution'
         b' is an automated program analysis technique that employs an SMT solv'
         b'er to systematically explore paths through a program. It has been ac'
         b'knowledged in recent years as a highly effective technique for gener'
         b'ating high-coverage test suites as well as for uncovering deep corne'
         b'r-case bugs in complex real-world software, and one of the key facto'
         b'rs responsible for that success are the tremendous advances in SMT-s'
         b'olving technology. Nevertheless, constraint solving remains one of t'
         b'he fundamental challenges of symbolic execution, and for many progra'
         b'ms it is the main performance bottleneck.</p>\r\n<p>In this talk, '
         b'I will first give a very general introduction to symbolic execution,'
         b' and then I will present the results reported in our CAV 2013 paper '
         b'on integrating support for multiple SMT solvers in the dynamic symbo'
         b'lic execution engine KLEE. In particular, I will outline the key cha'
         b'racteristics of the SMT queries generated during symbolic execution,'
         b' describe several high-level optimisations that KLEE employs to expl'
         b'oit those characteristics, introduce an extension of KLEE that uses '
         b'a number of state-of-the-art SMT solvers (Boolector, STP and Z3) thr'
         b"ough the metaSMT solver framework, and compare the solvers' performa"
         b'nce when run under KLEE. In addition, I will discuss several options'
         b' for designing a parallel portfolio solver for symbolic execution to'
         b'ols. This is joint work with Cristian Cadar.</p>\r\n</td>\r\n</t'
         b'r>\r\n</table></div><div class="csc-default"><div class="divider">'
         b'<hr /></div></div><div id="c27950" class="csc-default"><table>\r\n'
         b'<tr>\r\n<th>Time / date:</th>\r\n<td>Wed 12th November 2014, 4-5pm</'
         b'td>\r\n</tr>\r\n<tr>\r\n<th>Speaker:</th>\r\n<td><a href="http://www'
         b'0.cs.ucl.ac.uk/staff/R.Rowe/">Reuben Rowe</a>, PPLV, University Coll'
         b'ege London</td>\r\n</tr>\r\n<tr>\r\n<th>Location:</th>\r\n<td>1.03 M'
         b'alet Place Engineering Building (MPEB)</td>\r\n</tr>\r\n<tr>\r\n<t'
         b"h>Title:</th>\r\n<td>Towards Type Inference for Nakano's Modality<"
         b'/td>\r\n</tr>\r\n<tr>\r\n<th>Abstract:</th>\r\n<td>\r\n<p>Around f'
         b'ifteen years ago, Nakano introduced an extension to a system of recu'
         b'rsive types for the Lambda Calculus consisting of a unary type const'
         b'ructor, or modality, guarding the occurrences of recursive reference'
         b's. This modest extension afforded a powerful result: the guarantee o'
         b'f a particular kind of termination (specifically, head normalisation'
         b'). That is, programs typeable in this system are guaranteed to produ'
         b'ce output.</p>\r\n<p>Since then, much research has been done to un'
         b'derstand the semantics of this modality, and utilise it in more soph'
         b'isticated type systems. Notable contributions to this effort include'
         b': the work of Birkedal et al. and Benton and Krishnaswami, who study'
         b' semantic models induced by the modality; research by Appel at al. a'
         b'nd Pottier who employ the modality in typed intermediate representat'
         b'ions of programs; and Atkey and McBride\xe2\x80\x99s work on co-p'
         b'rogramming for infinite data.</p>\r\n<p>While some of this work ex'
         b'plicitly addresses the possibility of type checking (e.g., that of P'
         b'ottier), to the best of our knowledge type inference is still an uns'
         b'olved problem. The lack of a type inference procedure presents a sig'
         b'nificant barrier to the wider adoption of Nakano\xe2\x80\x99s tec'
         b'hnique in practice. In this talk, I will describe a (conservative) e'
         b'xtension to Nakano\xe2\x80\x99s system which allows for the devel'
         b'opment of a (sound but incomplete) unification-based algorithm for d'
         b'eciding whether a term is typeable by constructing a suitably genera'
         b'l type.</p>\r\n</td>\r\n</tr>\r\n</table></div><div class="csc-def'
         b'ault"><div class="divider"><hr /></div></div><div id="c21793" class='
         b'"csc-default">\n\t\t\t\t<table class="contenttable contenttable-0'
         b'">\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="'
         b'td-0" scope="row" id="row21793-0">Time / date:</th>\n\t\t\t\t\t\t\t<'
         b'td class="td-1" headers="row21793-0"> Wed 15th October 2014, 4-5pm <'
         b'/td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row21793-0"> <'
         b'/td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t'
         b'\t\t\t\t\t<th class="td-0" scope="row" id="row21793-1">Speaker:</'
         b'th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row21793-1"> Carsten Fu'
         b'hs, PPLV, UCL </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers='
         b'"row21793-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even t'
         b'r-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row21793-2">Lo'
         b'cation:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row21793-2"> 1'
         b'.02 Malet Place Engineering Building (MPEB) </td>\n\t\t\t\t\t\t\t<td'
         b' class="td-last td-2" headers="row21793-2"> </td>\n\t\t\t\t\t</tr>'
         b'\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-'
         b'0" scope="row" id="row21793-3">Title:</th>\n\t\t\t\t\t\t\t<td class='
         b'"td-1" headers="row21793-3"> Disproving termination with overapproxi'
         b'mation </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row217'
         b'93-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4'
         b'">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row21793-4">Abstr'
         b'act:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row21793-4"> When'
         b' disproving termination using known techniques (e.g. recurrence sets'
         b'), abstractions that overapproximate the program\xe2\x80\x99s tra'
         b'nsition relation are unsound. We introduce live abstractions, a natu'
         b'ral class of abstractions that can be combined with the recent conce'
         b'pt of closed recurrence sets to soundly disprove termination. To dem'
         b'onstrate the practical usefulness of this new approach we show how p'
         b'rograms with nonlinear, nondeterministic, and heap-based commands ca'
         b'n be shown nonterminating using linear overapproximations. This talk'
         b" is about joint work with Byron Cook, Kaustubh Nimkar, and Peter O'H"
         b'earn. </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row2179'
         b'3-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-las'
         b't">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row21793-5"> </t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-1" headers="row21793-5"> </td>\n\t'
         b'\t\t\t\t\t\t<td class="td-last td-2" headers="row21793-5"> </td>\n\t'
         b'\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><di'
         b'v class="divider"><hr /></div></div><div id="c21771" class="csc-defa'
         b'ult">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t\t'
         b'\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" sco'
         b'pe="row" id="row21771-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class='
         b'"td-1" headers="row21771-0">Wed 1st October 2014, 4-5pm </td>\n\t\t'
         b'\t\t\t\t\t<td class="td-last td-2" headers="row21771-0"> </td>\n\t\t'
         b'\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t<t'
         b'h class="td-0" scope="row" id="row21771-1">Speaker:</th>\n\t\t\t'
         b'\t\t\t\t<td class="td-1" headers="row21771-1"> Ana Armas, University'
         b' of Oxford </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="ro'
         b'w21771-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2'
         b'">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row21771-2">Locat'
         b'ion:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row21771-2"> 1.03'
         b' Malet Place Engineering Building (MPEB) </td>\n\t\t\t\t\t\t\t<td cl'
         b'ass="td-last td-2" headers="row21771-2"> </td>\n\t\t\t\t\t</tr'
         b'>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row21771-3">Title:</th>\n\t\t\t\t\t\t\t<td class'
         b'="td-1" headers="row21771-3"> Ontology Module Extraction via Datalog'
         b' Reasoning </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="ro'
         b'w21771-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4'
         b'">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row21771-4">Abstr'
         b'act:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row21771-4"> Modu'
         b'le extraction---the task of computing a (preferably small) fragment '
         b'M of an ontology T that preserves entailments over a signature S---h'
         b'as found many applications in recent years. Extracting modules of mi'
         b'nimal size is, however, computationally hard, and often algorithmica'
         b'lly infeasible. Thus, practical techniques are based on approximatio'
         b'ns, where M provably captures the relevant entailments, but is not g'
         b'uaranteed to be minimal. Existing approximations, however, ensure th'
         b'at M preserves all second-order entailments of T w.r.t. S, which is '
         b'stronger than is required in many applications, and may lead to larg'
         b'e modules in practice. In this paper we propose a novel approach in '
         b'which module extraction is reduced to a reasoning problem in datalog'
         b'. Our approach not only generalises existing approximations in an el'
         b'egant way, but it can also be tailored to preserve only specific kin'
         b'ds of entailments, which allows us to extract significantly smaller '
         b'modules. An evaluation on widely-used ontologies has shown very enco'
         b'uraging results. </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" heade'
         b'rs="row21771-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd'
         b' tr-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row21771-'
         b'5"> </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row21771-5"> </td'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row21771-5"> </td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default">'
         b'<div class="divider"><hr /></div></div><div id="c19331" class="csc-d'
         b'efault">\n\t\t\t\t<table class="contenttable contenttable-0">'
         b'\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row19331-0">Time / date:</th>\n\t\t\t\t\t\t\t<td'
         b' class="td-1" headers="row19331-0">Wed 2nd July 2014, 4-5pm </td'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row19331-0"> </td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t'
         b'\t\t<th class="td-0" scope="row" id="row19331-1">Speaker:</th>'
         b'\n\t\t\t\t\t\t\t<td class="td-1" headers="row19331-1"> Vincent Nimal'
         b', University of Oxford </td>\n\t\t\t\t\t\t\t<td class="td-last td-2"'
         b' headers="row19331-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="'
         b'tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row19'
         b'331-2">Location:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row19'
         b'331-2"> 6.12 Malet Place Engineering </td>\n\t\t\t\t\t\t\t<td class='
         b'"td-last td-2" headers="row19331-2"> </td>\n\t\t\t\t\t</tr>\n\t\t'
         b'\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0" scop'
         b'e="row" id="row19331-3">Title:</th>\n\t\t\t\t\t\t\t<td class="td-1" '
         b'headers="row19331-3"> Don\xe2\x80\x99t sit on the fence: A static'
         b' analysis approach to automatic fence insertion </td>\n\t\t\t\t\t\t'
         b'\t<td class="td-last td-2" headers="row19331-3"> </td>\n\t\t\t\t\t<'
         b'/tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<th class'
         b'="td-0" scope="row" id="row19331-4">Abstract:</th>\n\t\t\t\t\t\t\t<t'
         b'd class="td-1" headers="row19331-4"> Modern architectures rely on me'
         b'mory fences to prevent undesired weakenings of memory consistency. A'
         b's the fences\xe2\x80\x99 semantics may be subtle, the automation '
         b'of their placement is highly desirable. But precise methods for rest'
         b'oring consistency do not scale to deployed systems code. We choose t'
         b'o trade some precision for genuine scalability: our technique is sui'
         b'table for large code bases. We implement it in our new musketeer too'
         b'l, and detail experiments on more than 350 executables of packages f'
         b'ound in Debian Linux 7.1, e.g.memcached (about 10000 LoC).  This tal'
         b'k will be presented at CAV and should last about 15 minutes. This is'
         b' joint work with Jade Alglave, Daniel Kroening and Daniel Poetzl. Pl'
         b'ease do not hesitate to comment the slides and structure of the talk'
         b' -- we will really appreciate it! </td>\n\t\t\t\t\t\t\t<td class="td'
         b'-last td-2" headers="row19331-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t'
         b'<tr class="tr-odd tr-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="r'
         b'ow" id="row19331-5"> </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="'
         b'row19331-5"> </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="'
         b'row19331-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div cla'
         b'ss="csc-default"><div class="divider"><hr /></div></div><div id="c18'
         b'799" class="csc-default">\n\t\t\t\t<table class="contenttable con'
         b'tenttable-0">\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t'
         b'<th class="td-0" scope="row" id="row18799-0">Time / date:</th>\n\t'
         b'\t\t\t\t\t\t<td class="td-1" headers="row18799-0">Wed 18th June 20'
         b'14, 4-5pm </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row'
         b'18799-0"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">'
         b'\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18799-1">Speaker'
         b':</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18799-1">Caterina'
         b' Urban, ENS Paris </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" head'
         b'ers="row18799-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-ev'
         b'en tr-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18799-2'
         b'">Location:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18799-2'
         b'"> Roberts 309 </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers'
         b'="row18799-2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd t'
         b'r-3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18799-3">Ti'
         b'tle:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18799-3"> Auto'
         b'matic Inference of Ranking Functions by Abstract Interpretation </td'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18799-3"> </td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t'
         b'\t\t\t<th class="td-0" scope="row" id="row18799-4">Abstract:</t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18799-4"> We present '
         b'a family of parameterized abstract domains for proving termination o'
         b'f imperative programs by abstract interpretation. The domains automa'
         b'tically synthesize piecewise-defined lexicographic ranking functions'
         b' and infer sufficient preconditions for program termination.  The ab'
         b'stract domains are parameterized by a numerical abstract domain for '
         b'state partitioning and a numerical abstract domain for ranking funct'
         b'ions. This parameterization allows to easily tune the trade-off betw'
         b'een precision and cost of the analysis. We describe instantiations o'
         b'f these domains with intervals, octagons, polyhedra and affine funct'
         b'ions.  We have implemented a prototype static analyzer for proving c'
         b'onditional termination of programs written in (a subset of) C and, u'
         b'sing experimental evidence, we show that it is competitive with the '
         b'state of the art and performs well on a wide variety of benchmarks. '
         b'</td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18799-4"> '
         b'</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-last">\n\t\t'
         b'\t\t\t\t\t<th class="td-0" scope="row" id="row18799-5"> </th>'
         b'\n\t\t\t\t\t\t\t<td class="td-1" headers="row18799-5"> </td>\n\t\t\t'
         b'\t\t\t\t<td class="td-last td-2" headers="row18799-5"> </td>\n\t\t\t'
         b'\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><div clas'
         b's="divider"><hr /></div></div><div id="c18798" class="csc-defaul'
         b't">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t\t\t\t'
         b'\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" scope'
         b'="row" id="row18798-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class="t'
         b'd-1" headers="row18798-0">Wed 4th June 2014, 4-5pm </td>\n\t\t\t'
         b'\t\t\t\t<td class="td-last td-2" headers="row18798-0"> </td>\n\t\t\t'
         b'\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t<th cla'
         b'ss="td-0" scope="row" id="row18798-1">Speaker:</th>\n\t\t\t\t\t\t\t<'
         b'td class="td-1" headers="row18798-1"> Eric Koskinen, New York Univer'
         b'sity </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18798'
         b'-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2">'
         b'\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18798-2">Locatio'
         b'n:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18798-2"> 6.12 M'
         b'alet Place Engineering </td>\n\t\t\t\t\t\t\t<td class="td-last td-2"'
         b' headers="row18798-2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="'
         b'tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row187'
         b'98-3">Title:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18798-'
         b'3"> Local Temporal Reasoning </td>\n\t\t\t\t\t\t\t<td class="td-last'
         b' td-2" headers="row18798-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr c'
         b'lass="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id='
         b'"row18798-4">Abstract:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers='
         b'"row18798-4"> I will discuss our recent development of the first met'
         b'hod for proving temporal logic properties of programs written in hig'
         b'her-order languages such as C#, F#, Haskell, Ocaml, Perl, Ruby, Pyth'
         b'on, etc. By distinguishing between the finite traces and infinite tr'
         b'aces in the specification, we obtain rules that permit us to reason '
         b'about the temporal behavior of program parts via a type-and-effect s'
         b'ystem, which is then able to compose these facts together to prove t'
         b'he overall target property of the program. The type system alone is '
         b'strong enough to derive many temporal safety properties, for example'
         b' when using dependent (refinement) types and temporal effects. We al'
         b'so show how existing techniques can be used as oracles to provide li'
         b'veness information (e.g. termination) about program parts and that t'
         b'he type-and-effect system can combine this information with temporal'
         b' safety information to derive nontrivial temporal properties.  Our w'
         b'ork has application toward verification of higher-order software, as'
         b' well as modular strategies for interprocedural programs. Joint work'
         b' with Tachio Terauchi. To appear in LICS 2014. </td>\n\t\t\t\t\t\t\t'
         b'<td class="td-last td-2" headers="row18798-4"> </td>\n\t\t\t\t\t</'
         b'tr>\n\t\t\t\t\t<tr class="tr-odd tr-last">\n\t\t\t\t\t\t\t<th clas'
         b's="td-0" scope="row" id="row18798-5"> </th>\n\t\t\t\t\t\t\t<td class'
         b'="td-1" headers="row18798-5"> </td>\n\t\t\t\t\t\t\t<td class="td-las'
         b't td-2" headers="row18798-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</tab'
         b'le></div><div class="csc-default"><div class="divider"><hr /></div><'
         b'/div><div id="c18797" class="csc-default">\n\t\t\t\t<table class='
         b'"contenttable contenttable-0">\n\t\t\t\t\t<tr class="tr-even tr-0"'
         b'>\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18797-0">Time /'
         b' date: </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18797-0"> W'
         b'ed 21st May 2014, 4-5pm </td>\n\t\t\t\t\t\t\t<td class="td-last td-2'
         b'" headers="row18797-0"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class='
         b'"tr-odd tr-1">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18'
         b'797-1">Speaker: </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18'
         b'797-1"> Ross Duncan, Univ. Strathclyde </td>\n\t\t\t\t\t\t\t<td clas'
         b's="td-last td-2" headers="row18797-1"> </td>\n\t\t\t\t\t</tr>\n'
         b'\t\t\t\t\t<tr class="tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td-'
         b'0" scope="row" id="row18797-2">Location: </th>\n\t\t\t\t\t\t\t<td cl'
         b'ass="td-1" headers="row18797-2"> Roberts 309 </td>\n\t\t\t\t\t\t\t<t'
         b'd class="td-last td-2" headers="row18797-2"> </td>\n\t\t\t\t\t</tr'
         b'>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row18797-3">Title: </th>\n\t\t\t\t\t\t\t<td clas'
         b's="td-1" headers="row18797-3"> Verifying Quantum Computations with G'
         b'raphical Calculi </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" heade'
         b'rs="row18797-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-eve'
         b'n tr-4">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18797-4"'
         b'>Abstract: </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18797-4'
         b'"> Quantum computation takes place in a mathematical environment rat'
         b'her different to the familiar world of classical computing.  Phenome'
         b"na such as complementarity and entanglement don't have any counterpa"
         b'rt in the systems usually studied by computer scientists, and the us'
         b"ual logical structures we rely on to analyse computation don't exist"
         b'.  However, studying the unique features of the quantum world reveal'
         b's that quantum computation can be formalised using the theory of mon'
         b'oidal categories, where various internal algebras do the heavy lifti'
         b'ng.  This theory can be expressed in purely diagrammatic terms, and '
         b'equational reasoning can be carried out by rewriting in a graphical '
         b"calculus.  I'll introduce the relevant structures and show how to ve"
         b'rify the correctness of some quantum programs using these techniques'
         b'. </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18797-4"'
         b'> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-last">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18797-5"> </t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18797-5"> </td>\n\t'
         b'\t\t\t\t\t\t<td class="td-last td-2" headers="row18797-5"> </td>\n\t'
         b'\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><di'
         b'v class="divider"><hr /></div></div><div id="c18794" class="csc-defa'
         b'ult">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t\t'
         b'\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" sco'
         b'pe="row" id="row18794-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class='
         b'"td-1" headers="row18794-0">Wed 23rd April 2014, 4-5pm </td>\n\t\t\t'
         b'\t\t\t\t<td class="td-last td-2" headers="row18794-0"> </td>\n\t\t\t'
         b'\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t<th cla'
         b'ss="td-0" scope="row" id="row18794-1">Speaker:</th>\n\t\t\t\t\t\t\t<'
         b'td class="td-1" headers="row18794-1"> Will Sonnex, University of Cam'
         b'bridge </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row187'
         b'94-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2'
         b'">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18794-2">Locat'
         b'ion:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18794-2"> Robe'
         b'rts 309 </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18'
         b'794-2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3'
         b'">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18794-3">Title'
         b':</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18794-3"> Proving'
         b' terms equivalent using fixpoint fusion </td>\n\t\t\t\t\t\t\t<td cla'
         b'ss="td-last td-2" headers="row18794-3"> </td>\n\t\t\t\t\t</tr>'
         b'\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row18794-4">Abstract:</th>\n\t\t\t\t\t\t\t<td cl'
         b'ass="td-1" headers="row18794-4"> When working with functional progra'
         b'mming languages the traditional approach to proving two terms equiva'
         b'lent is to use proof by induction. We can use this to prove boolean '
         b'properties by checking if such a term is equal to &quot;True&quot;. '
         b'Automated proof by induction is therefore a powerful tool for verify'
         b'ing functional programs.My work is focused on proving terms equivale'
         b'nt using term rewriting techniques, particularly fixpoint fusion, to'
         b' simplify terms within a property until the property is trivially tr'
         b'ue. For equations this would be simplifying both sides to alpha-equa'
         b'l terms. For properties this would be rewriting the term to &quot;Tr'
         b'ue&quot;.  I will demo my automated term rewriting program &quot;Ele'
         b'a&quot;, which is able to perform as well as the previous state of t'
         b'he art (up until 2 years ago, damn you HipSpec) in automated inducti'
         b'on. </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18794-'
         b'4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-last"'
         b'>\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18794-5"> </th>'
         b'\n\t\t\t\t\t\t\t<td class="td-1" headers="row18794-5"> </td>\n\t\t\t'
         b'\t\t\t\t<td class="td-last td-2" headers="row18794-5"> </td>\n\t\t\t'
         b'\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><div clas'
         b's="divider"><hr /></div></div><div id="c18790" class="csc-defaul'
         b't">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t\t\t\t'
         b'\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" scope'
         b'="row" id="row18790-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class="t'
         b'd-1" headers="row18790-0">Wed 9th April 2014, 4-5pm </td>\n\t\t'
         b'\t\t\t\t\t<td class="td-last td-2" headers="row18790-0"> </td>\n\t\t'
         b'\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t<t'
         b'h class="td-0" scope="row" id="row18790-1">Speaker:</th>\n\t\t\t'
         b'\t\t\t\t<td class="td-1" headers="row18790-1"> Gabrielle Anderson, U'
         b'CL </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18790-1'
         b'"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row18790-2">Location:'
         b'</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18790-2"> Roberts '
         b'309 </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18790-'
         b'2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row18790-3">Title:</t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18790-3"> Bunched Res'
         b'ource Process Calculus </td>\n\t\t\t\t\t\t\t<td class="td-last td-2"'
         b' headers="row18790-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="'
         b'tr-even tr-4">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18'
         b'790-4">Abstract:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18'
         b'790-4"> The Synchronous Calculus of Resources and Processes by Pym a'
         b'nd others aims to provide a methodology for systems modelling that f'
         b'ollows intuition about how complex systems consist of objects as wel'
         b'l as dynamics, and that provides compositionality in terms of behavi'
         b'our and of logical properties. While this work achieved most of its '
         b'aims it had one significant drawback: it did not have one direction '
         b'of the Hennessey Milner property, that logically equivalent systems '
         b'are also behaviourally equivalent. In this work we present a variant'
         b' on SCRP that we call BRPC, and show that it has both directions of '
         b'the HM property. </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" heade'
         b'rs="row18790-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd'
         b' tr-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18790-'
         b'5"> </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18790-5"> </td'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18790-5"> </td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default">'
         b'<div class="divider"><hr /></div></div><div id="c18788" class="csc-d'
         b'efault">\n\t\t\t\t<table class="contenttable contenttable-0">'
         b'\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row18788-0">Time / date:</th>\n\t\t\t\t\t\t\t<td'
         b' class="td-1" headers="row18788-0">Wed 26th March 2014, 4-5pm </'
         b'td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18788-0"> </'
         b'td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t'
         b'\t\t\t\t<th class="td-0" scope="row" id="row18788-1">Speaker:</t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18788-1"> Mehrnoosh S'
         b'adrzadeh, Queen Mary University of London  </td>\n\t\t\t\t\t\t\t<td '
         b'class="td-last td-2" headers="row18788-1"> </td>\n\t\t\t\t\t</tr>\n'
         b'\t\t\t\t\t<tr class="tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td-'
         b'0" scope="row" id="row18788-2">Location:</th>\n\t\t\t\t\t\t\t<td cla'
         b'ss="td-1" headers="row18788-2"> Malet Engineering 1.20 </td>\n\t\t\t'
         b'\t\t\t\t<td class="td-last td-2" headers="row18788-2"> </td>\n\t\t\t'
         b'\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t<th cla'
         b'ss="td-0" scope="row" id="row18788-3">Title:</th>\n\t\t\t\t\t\t\t<td'
         b' class="td-1" headers="row18788-3"> Compositional Vector Space Model'
         b's of Natural Language </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" '
         b'headers="row18788-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="t'
         b'r-even tr-4">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row187'
         b'88-4">Abstract:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row187'
         b'88-4"> Vector space models of natural language originated in the wor'
         b"k of Chomsky's supervisor: Z. Harris. They represent meanings of wor"
         b'ds by vectors whose coefficients are the frequency of co-occurrence '
         b'of the word in different contexts. They have proved successful in va'
         b'rious natural language tasks  (e.g. automatic thesauri construction)'
         b', but  have been unable to represent meanings of sentences. I will p'
         b'resent a model that solves this problem by combining the vector spac'
         b'e model with the grammatical structures of sentences. The latter are'
         b' type-algebras that vary over monoidal structures originated in the '
         b'work of J. Lambek. The combination  is made possible via a homomorph'
         b'ic passage from the monoidal structures to vector spaces. This is jo'
         b'int work with a bunch of people such as Coecke (Oxford) and Clark (C'
         b'ambridge). The inspirations behind the work was from categorical mod'
         b'els of quantum mechanics (which also has a vector space model) devel'
         b'oped by Abramsky and Coecke. </td>\n\t\t\t\t\t\t\t<td class="td-last'
         b' td-2" headers="row18788-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr c'
         b'lass="tr-odd tr-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" i'
         b'd="row18788-5"> </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18'
         b'788-5"> </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18'
         b'788-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="c'
         b'sc-default"><div class="divider"><hr /></div></div><div id="c18786" '
         b'class="csc-default">\n\t\t\t\t<table class="contenttable contentt'
         b'able-0">\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th c'
         b'lass="td-0" scope="row" id="row18786-0">Time / date:</th>\n\t\t'
         b'\t\t\t\t\t<td class="td-1" headers="row18786-0">Wed 12th March 20'
         b'14 4-5pm </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row1'
         b'8786-0"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-'
         b'1">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18786-1">Spea'
         b'ker:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18786-1"> Gare'
         b'th Smith, Imperial College London </td>\n\t\t\t\t\t\t\t<td class="td'
         b'-last td-2" headers="row18786-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t'
         b'<tr class="tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row'
         b'" id="row18786-2">Location:</th>\n\t\t\t\t\t\t\t<td class="td-1" hea'
         b'ders="row18786-2"> MPEB 1.03  </td>\n\t\t\t\t\t\t\t<td class="td-las'
         b't td-2" headers="row18786-2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr '
         b'class="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id='
         b'"row18786-3">Title:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="ro'
         b'w18786-3"> A Trusted Mechanised JavaScript Specification </td>\n\t'
         b'\t\t\t\t\t\t<td class="td-last td-2" headers="row18786-3"> </td>\n\t'
         b'\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t'
         b'<th class="td-0" scope="row" id="row18786-4">Abstract:</th>\n'
         b'\t\t\t\t\t\t\t<td class="td-1" headers="row18786-4"> JavaScript is '
         b'the most widely used web language for client-side applications. Whil'
         b'st the development of JavaScript was initially just led by implement'
         b'ation, there is now increasing momentum behind the ECMA standardisat'
         b'ion process. The time is ripe for a formal, mechanised specification'
         b' of JavaScript, to clarify ambiguities in the ECMA standards, to ser'
         b've as a trusted reference for high-level language compilation and Ja'
         b'vaScript implementations, and to provide a platform for high-assuran'
         b'ce proofs of language properties.  This talk presents JSCert, a form'
         b'alisation of the current ECMA standard in the Coq proof assistant, a'
         b'nd JSRef, a reference interpreter for JavaScript extracted from Coq '
         b'to OCaml. We have a Coq proof that JSRef is correct with respect to '
         b'JSCert and have assessed JSRef using test262, the ECMA conformance t'
         b'est suite. Our methodology ensures that JSCert is a comparatively ac'
         b'curate formulation of the English standard, which will only improve '
         b'as time goes on. We have demonstrated that modern techniques of mech'
         b'anised specification can handle the complexity of JavaScript. </'
         b'td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18786-4"> </'
         b'td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-last">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18786-5"> </t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18786-5"> </td>\n\t'
         b'\t\t\t\t\t\t<td class="td-last td-2" headers="row18786-5"> </td>\n\t'
         b'\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><di'
         b'v class="divider"><hr /></div></div><div id="c18392" class="csc-defa'
         b'ult">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t\t'
         b'\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" sco'
         b'pe="row" id="row18392-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class='
         b'"td-1" headers="row18392-0">Wed 13th November 2013, 2-3pm </td>\n'
         b'\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18392-0"> </td>\n'
         b'\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t'
         b'<th class="td-0" scope="row" id="row18392-1">Speaker:</th>\n\t'
         b'\t\t\t\t\t\t<td class="td-1" headers="row18392-1">Pavle Subotic   '
         b'</td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18392-1"> '
         b'</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18392-2">Location'
         b':</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18392-2"> Roberts'
         b' 421  </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row1839'
         b'2-2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3">'
         b'\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18392-3">Title:<'
         b'/th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18392-3"> Exploring'
         b' Interpolants </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers='
         b'"row18392-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even t'
         b'r-4">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18392-4">Ab'
         b'stract:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18392-4">Cr'
         b'aig Interpolation is a standard method to construct and refine abstr'
         b'actions in model checking. To obtain abstractions that are suitable '
         b'for the verification of a software programs or hardware designs, mod'
         b'el checkers rely on theoremprovers to find the right interpolants, o'
         b'r interpolants containing the right predicates, in a generally infin'
         b'ite lattice of interpolants for any given interpolation problem. The'
         b' problem of guiding solvers to the right interpolants has so far bee'
         b'n investigated mainly on a syntactic level. In this talk I present a'
         b' semantic and solver-independent framework for systematically explor'
         b'ing interpolant lattices, based on the notion of interpolation abstr'
         b'action. I will discuss how interpolation abstractions can be constru'
         b'cted for a variety of logics, and how they can be exploited in the c'
         b'ontext of software model checking  </td>\n\t\t\t\t\t\t\t<td class="t'
         b'd-last td-2" headers="row18392-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t'
         b'\t<tr class="tr-odd tr-last">\n\t\t\t\t\t\t\t<th class="td-0" sco'
         b'pe="row" id="row18392-5"> </th>\n\t\t\t\t\t\t\t<td class="td-1" head'
         b'ers="row18392-5"> </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" head'
         b'ers="row18392-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><di'
         b'v class="csc-default"><div class="divider"><hr /></div></div><div id'
         b'="c18535" class="csc-default">\n\t\t\t\t<table class="contenttabl'
         b'e contenttable-0">\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t'
         b'\t\t\t\t\t<th class="td-0" scope="row" id="row18535-0">Time / dat'
         b'e:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18535-0">Friday '
         b'8th November 2013, 4-5pm </td>\n\t\t\t\t\t\t\t<td class="td-last td-'
         b'2" headers="row18535-0"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class'
         b'="tr-odd tr-1">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row1'
         b'8535-1">Speaker:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18'
         b'535-1">Thomas Stroeder  </td>\n\t\t\t\t\t\t\t<td class="td-last td-2'
         b'" headers="row18535-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class='
         b'"tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row1'
         b'8535-2">Location:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row1'
         b'8535-2"> Roberts 309 </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" h'
         b'eaders="row18535-2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr'
         b'-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18535'
         b'-3">Title:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18535-3"'
         b'> Proving Deadlock and Livelock Freedom </td>\n\t\t\t\t\t\t\t<td cla'
         b'ss="td-last td-2" headers="row18535-3"> </td>\n\t\t\t\t\t</tr>'
         b'\n\t\t\t\t\t<tr class="tr-even tr-last">\n\t\t\t\t\t\t\t<th class='
         b'"td-0" scope="row" id="row18535-4">Abstract:</th>\n\t\t\t\t\t\t\t<td'
         b' class="td-1" headers="row18535-4">In this talk we develop a general'
         b' method for proving deadlock and livelock freedom of concurrent prog'
         b'rams with shared memory. Our goal in this work is to support program'
         b's which use locks stored in mutable data structures. The key to our '
         b'technique is the observation that dependencies between locks can be '
         b'abstracted using recursion and non-determinism in a sequential progr'
         b'am such that the termination of the abstraction implies deadlock and'
         b' livelock freedom. We discuss applications to examples including loc'
         b'k-coupling lists, the optimistic skiplist of Heller et al., the lock'
         b'-based queue of Michael and Scott, and the balanced binary trees of '
         b'Kung and Lehman, Bronson et al., and Schlatter Ellis. </td>\n'
         b'\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18535-4"> </td>\n'
         b'\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><d'
         b'iv class="divider"><hr /></div></div><div id="c18391" class="csc-def'
         b'ault">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t'
         b'\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" sc'
         b'ope="row" id="row18391-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class'
         b'="td-1" headers="row18391-0">Fri 11th Oct 2013, 4-5pm </td>\n'
         b'\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18391-0"> </td>\n'
         b'\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t'
         b'<th class="td-0" scope="row" id="row18391-1">Speaker:</th>\n\t'
         b'\t\t\t\t\t\t<td class="td-1" headers="row18391-1">Aquinas Hobor  <'
         b'/td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18391-1"> <'
         b'/td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row18391-2">Location:'
         b'</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18391-2"> Roberts '
         b'508 </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18391-'
         b'2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row18391-3">Title:</t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18391-3"> Decision Pr'
         b'ocedures over Sophisticated Fractional Permissions </td>\n\t\t\t'
         b'\t\t\t\t<td class="td-last td-2" headers="row18391-3"> </td>\n\t\t\t'
         b'\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<th cl'
         b'ass="td-0" scope="row" id="row18391-4">Abstract:</th>\n\t\t\t\t\t\t'
         b'\t<td class="td-1" headers="row18391-4">Fractional permissions en'
         b'able sophisticated management of resource accesses in both sequentia'
         b'l and concurrent programs. Entailment checkers for formulae that con'
         b'tain fractional permissions must be able to reason about said permis'
         b'sions to verify the entailments. We show how entailment checkers for'
         b' separation logic with fractional permissions can extract equation s'
         b'ystems over fractional shares. We develop a set decision procedures '
         b'over equations drawn from the sophisticated boolean binary tree frac'
         b'tional permission model developed by Dockins et al. [4]. We prove th'
         b'at our procedures are sound and complete and discuss their computati'
         b'onal complexity. We explain our implementation and provide benchmark'
         b's to help understand its performance in practice. We detail how our '
         b'implementation has been integrated into the HIP/SLEEK verifi cation '
         b'toolset. We have machine-checked proofs in Coq. </td>\n\t\t\t\t\t\t'
         b'\t<td class="td-last td-2" headers="row18391-4"> </td>\n\t\t\t\t\t<'
         b'/tr>\n\t\t\t\t\t<tr class="tr-odd tr-last">\n\t\t\t\t\t\t\t<th cla'
         b'ss="td-0" scope="row" id="row18391-5"> </th>\n\t\t\t\t\t\t\t<td clas'
         b's="td-1" headers="row18391-5"> </td>\n\t\t\t\t\t\t\t<td class="td-la'
         b'st td-2" headers="row18391-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</ta'
         b'ble></div><div class="csc-default"><div class="divider"><hr /></div>'
         b'</div><div id="c18369" class="csc-default">\n\t\t\t\t<table class'
         b'="contenttable contenttable-0">\n\t\t\t\t\t<tr class="tr-even tr-0'
         b'">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18369-0">Time '
         b'/ date:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18369-0">Fr'
         b'i 27th Sept 2013, 4-5pm  </td>\n\t\t\t\t\t\t\t<td class="td-last td-'
         b'2" headers="row18369-0"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class'
         b'="tr-odd tr-1">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row1'
         b'8369-1">Speaker:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18'
         b'369-1">Viktor Vafeiadis  </td>\n\t\t\t\t\t\t\t<td class="td-last td-'
         b'2" headers="row18369-1"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class'
         b'="tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row'
         b'18369-2">Location:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row'
         b'18369-2"> \tRoberts 309 </td>\n\t\t\t\t\t\t\t<td class="td-last t'
         b'd-2" headers="row18369-2"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr cla'
         b'ss="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="ro'
         b'w18369-3">Title:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18'
         b'369-3"> Relaxed separation logic: A program logic for C11 concurrenc'
         b'y</td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18369-3">'
         b' </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t'
         b'\t\t\t\t<th class="td-0" scope="row" id="row18369-4">Abstract:</'
         b'th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18369-4">The talk wi'
         b'll introduce relaxed separation logic (RSL), a program logic for rea'
         b'soning about concurrent programs running under the C11 relaxed memor'
         b"y model. From a user's perspective, RSL is an extension of concurren"
         b't separation logic (CSL) with proof rules for the various kinds of C'
         b'11 atomic accesses. As in CSL, individual threads are allowed to acc'
         b'ess non-atomically only the memory that they own, thus preventing da'
         b'ta races. Ownership can, however, be transferred via certain atomic '
         b'accesses. For SC-atomic accesses, arbitrary ownership transfer can o'
         b'ccur; for acquire/release atomic accesses, ownership transfer can oc'
         b'cur only in one direction; while for relaxed atomic accesses, no own'
         b'ership transfer is possible.</td>\n\t\t\t\t\t\t\t<td class="td-last '
         b'td-2" headers="row18369-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr cl'
         b'ass="tr-odd tr-5">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="r'
         b'ow18369-5"> </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18369-'
         b'5"> </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row18369-'
         b'5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-last'
         b'">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row18369-6"> </th'
         b'>\n\t\t\t\t\t\t\t<td class="td-1" headers="row18369-6"> </td>\n\t\t'
         b'\t\t\t\t\t<td class="td-last td-2" headers="row18369-6"> </td>\n\t\t'
         b'\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><div cla'
         b'ss="divider"><hr /></div></div><div id="c14629" class="csc-default">'
         b'\n\t\t\t\t<table class="contenttable contenttable-0">\n\t\t\t\t\t<t'
         b'r class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" '
         b'id="row14629-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class="td-1" he'
         b'aders="row14629-0">Fri 21st June 2013, 4-5pm  </td>\n\t\t\t\t\t\t\t<'
         b'td class="td-last td-2" headers="row14629-0"> </td>\n\t\t\t\t\t</t'
         b'r>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t<th class="t'
         b'd-0" scope="row" id="row14629-1">Speaker:</th>\n\t\t\t\t\t\t\t<td cl'
         b'ass="td-1" headers="row14629-1">Joel Ouaknine </td>\n\t\t\t\t\t\t\t<'
         b'td class="td-last td-2" headers="row14629-1"> </td>\n\t\t\t\t\t</t'
         b'r>\n\t\t\t\t\t<tr class="tr-even tr-2">\n\t\t\t\t\t\t\t<th class="'
         b'td-0" scope="row" id="row14629-2">Location:</th>\n\t\t\t\t\t\t\t<td '
         b'class="td-1" headers="row14629-2"> \tMalet Place Eng 1.02 </td>\n\t'
         b'\t\t\t\t\t\t<td class="td-last td-2" headers="row14629-2"> </td>\n\t'
         b'\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t<'
         b'th class="td-0" scope="row" id="row14629-3">Title:</th>\n\t\t\t\t'
         b'\t\t\t<td class="td-1" headers="row14629-3"> Decision Problems for '
         b'Linear Recurrence Sequences</td>\n\t\t\t\t\t\t\t<td class="td-last t'
         b'd-2" headers="row14629-3"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr cla'
         b'ss="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="r'
         b'ow14629-4">Abstract:</th>\n\t\t\t\t\t\t\t<td class="td-1" headers="r'
         b'ow14629-4">Linear recurrence sequences (such as the Fibonacci number'
         b's) permeate a vast number of areas of mathematics and computer scien'
         b'ce (in particular: program termination and probabilistic verificatio'
         b'n), and also have many applications in other fields such as economic'
         b's, theoretical biology, and statistical physics. In this talk, I wil'
         b'l focus on three fundamental decision problems for linear recurrence'
         b' sequences, namely the Skolem Problem (does the sequence have a zero'
         b'?), the Positivity Problem (are all terms of the sequence positive?)'
         b', and the Ultimate Positivity Problem (are all but finitely many ter'
         b'ms of the sequence positive?).  This is joint work with James Worrel'
         b'l and Matt Daws. </td>\n\t\t\t\t\t\t\t<td class="td-last td-2" heade'
         b'rs="row14629-4"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd'
         b' tr-5">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row14629-5">'
         b' </th>\n\t\t\t\t\t\t\t<td class="td-1" headers="row14629-5"> </t'
         b'd>\n\t\t\t\t\t\t\t<td class="td-last td-2" headers="row14629-5"> </t'
         b'd>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-last">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row14629-6"> </t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-1" headers="row14629-6"> </td>\n\t'
         b'\t\t\t\t\t\t<td class="td-last td-2" headers="row14629-6"> </td>\n\t'
         b'\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><di'
         b'v class="divider"><hr /></div></div><div id="c15773" class="csc-defa'
         b'ult">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t\t'
         b'\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" sco'
         b'pe="row" id="row15773-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class='
         b'"td-last td-1" headers="row15773-0">Fri 14th June 2013, 4-5pm</t'
         b'd>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t'
         b'\t\t\t<th class="td-0" scope="row" id="row15773-1">Speaker:</th'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15773-1">Abi S'
         b'ee</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2">\n\t\t'
         b'\t\t\t\t\t<th class="td-0" scope="row" id="row15773-2">Location:<'
         b'/th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15773-2">Ro'
         b'berts 309</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-'
         b'3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15773-3">Titl'
         b'e:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15773-3"'
         b'>Ramsey vs. lexicographic termination proving</td>\n\t\t\t\t\t</tr'
         b'>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="t'
         b'd-0" scope="row" id="row15773-4">Abstract:</th>\n\t\t\t\t\t\t\t<td c'
         b'lass="td-last td-1" headers="row15773-4">Termination proving has tra'
         b'ditionally been based on the search for (possibly lexicographic) ran'
         b'king functions. In recent years, however, the discovery of terminati'
         b'on proof techniques based on Ramsey\xe2\x80\x99s theorem have led'
         b' to new automation strategies, e.g. size-change, or iterative reduct'
         b'ions from termination to safety. We revisit the decision to use Rams'
         b'ey-based termination arguments in the iterative approach, and descri'
         b'be a new iterative termination proving procedure that instead search'
         b'es for lexicographic termination arguments. Using experimental evide'
         b'nce we show that this new method leads to dramatic speedups.</td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-last">\n\t\t'
         b'\t\t\t\t\t<th class="td-0" scope="row" id="row15773-5"> </th>'
         b'\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15773-5"> </td>'
         b'\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><'
         b'div class="divider"><hr /></div></div><div id="c15630" class="csc-de'
         b'fault">\n\t\t\t\t<table class="contenttable contenttable-0">\n'
         b'\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-'
         b'0" scope="row" id="row15630-0">Time / date:</th>\n\t\t\t\t\t\t\t<td '
         b'class="td-last td-1" headers="row15630-0">Fri 15th March 2013, 1-2pm'
         b'</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row15630-1">Speaker:<'
         b'/th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15630-1">Za'
         b'chary Kincaid</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr'
         b'-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15630-2">Loc'
         b'ation:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row1563'
         b'0-2">Malet Place Eng 1.20</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class'
         b'="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row1'
         b'5630-3">Title:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers='
         b'"row15630-3">Proving Correctness of Concurrent Programs with Data Fl'
         b'ow Graphs</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">'
         b'\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15630-4">Abstrac'
         b't:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15630-4"'
         b'>We propose inductive data flow graphs, data flow graphs with incorp'
         b'orated inductive assertions, as the basis of an approach to verifyin'
         b'g concurrent programs. An inductive data flow graph accounts for a s'
         b'et of dependencies between program events, and therefore stands as a'
         b' representation for the set of executions which give rise to these d'
         b'ependencies.  By representing information about dependencies rather '
         b'than control flow, inductive data flow graphs can yield very succinc'
         b't proofs.  Our strategy for verifying concurrent programs defers rea'
         b'soning about control to the proof checking step, a purely combinator'
         b'ial problem, thus avoiding the need to reason about data and control'
         b' simultaneously.</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd '
         b'tr-5">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15630-5"> '
         b'</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15630-5"> '
         b'</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-last">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row15630-6"> </th'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15630-6"> </td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default">'
         b'<div class="divider"><hr /></div></div><div id="c15618" class="csc-d'
         b'efault">\n\t\t\t\t<table class="contenttable contenttable-0">'
         b'\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row15618-0">Time / date:</th>\n\t\t\t\t\t\t\t<td'
         b' class="td-last td-1" headers="row15618-0">Fri 8th March 2013, 11am-'
         b'12pm</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row15618-1">Speaker:<'
         b'/th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15618-1">Al'
         b'exey Gotsman</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-'
         b'2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15618-2">Loca'
         b'tion:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15618'
         b'-2">6.12 MPEB</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-'
         b'3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15618-3">Titl'
         b'e:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15618-3"'
         b'>Abstraction for Weakly Consistent Systems</td>\n\t\t\t\t\t</tr>\n\t'
         b'\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="td-0" sc'
         b'ope="row" id="row15618-4">Abstract:</th>\n\t\t\t\t\t\t\t<td class="t'
         b'd-last td-1" headers="row15618-4">When constructing complex concurre'
         b'nt and distributed systems, abstraction is vital: programmers should'
         b' be able to reason about system components in terms of abstract spec'
         b'ifications that hide the implementation details. Nowadays such compo'
         b'nents often provide only weak consistency guarantees about the data '
         b'they manage: in shared-memory systems because of the effects of rela'
         b'xed memory models, and in distributed systems because of the effects'
         b' of replication. This makes existing notions of component abstractio'
         b'n inapplicable. In this talk I will describe our ongoing effort to s'
         b'pecify consistency guarantees provided by modern shared-memory and d'
         b'istributed systems in a uniform framework and to propose notions of '
         b'abstraction for components of such systems. I will illustrate our re'
         b'sults using the examples of the C/C++ memory model and eventually co'
         b'nsistent distributed systems. This is joint work with Mark Batty (Un'
         b'iversity of Cambridge), Sebastian Burckhardt (Microsoft Research), M'
         b'ike Dodds (University of York) and Hongseok Yang (University of Oxfo'
         b'rd).</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-5">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row15618-5"> </th'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15618-5"> </td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-last">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row15618-6"> </th'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15618-6"> </td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default">'
         b'<div class="divider"><hr /></div></div><div id="c15100" class="csc-d'
         b'efault">\n\t\t\t\t<table class="contenttable contenttable-0">'
         b'\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row15100-0">Time / date:</th>\n\t\t\t\t\t\t\t<td'
         b' class="td-last td-1" headers="row15100-0">Fri 1st March 2013, 4-5pm'
         b'</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row15100-1">Speaker:<'
         b'/th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15100-1">Sh'
         b'in Yoo</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2"'
         b'>\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15100-2">Locati'
         b'on:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15100-2'
         b'">MPEB 6.12</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3"'
         b'>\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15100-3">Title:'
         b'Fault</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15100'
         b'-3"> Localization Prioritization: Comparing Information Theoretic an'
         b'd Coverage Based Approaches</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr cla'
         b'ss="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="r'
         b'ow15100-4">Abstract:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" he'
         b'aders="row15100-4">Test case prioritization techniques seek to maxim'
         b'ise early fault detection. Fault localization seeks to use test case'
         b's already executed to help find the fault location. There is a natur'
         b'al interplay between the two techniques; once a fault is detected, w'
         b'e often switch focus to fault fixing, for which localization may be '
         b'a first step. In this paper we introduce the Fault Localization Prio'
         b'ritization (FLP) problem, which combines prioritization and localiza'
         b'tion. We evaluate three techniques: a novel FLP technique based on i'
         b'nformation theory, FLINT (Fault Localization using Information Theor'
         b'y), that we introduce in this paper, a standard Test Case Prioritiza'
         b'tion (TCP) technique and a \xe2\x80\x98test similarity technique\xe2'
         b'\x80\x99 used in previous work. Our evaluation uses five different'
         b' releases of four software systems. The results indicate that FLP an'
         b'd TCP can statistically significantly reduce fault localization cost'
         b's for 73% and 76% of cases respectively and that FLINT significantly'
         b' outperforms similarity-based localization techniques in 52% of the '
         b'cases considered in the study.</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr '
         b'class="tr-odd tr-5">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id='
         b'"row15100-5"> </th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers='
         b'"row15100-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even t'
         b'r-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15100-6"'
         b'> </th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15100-6"'
         b'> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-def'
         b'ault"><div class="divider"><hr /></div></div><div id="c15316" class='
         b'"csc-default">\n\t\t\t\t<table class="contenttable contenttable-0'
         b'">\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="'
         b'td-0" scope="row" id="row15316-0">Time / date:</th>\n\t\t\t\t\t\t\t<'
         b'td class="td-last td-1" headers="row15316-0">Fri 8th February 2013, '
         b'4-5pm</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15316-1">Speaker:'
         b'</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15316-1">T'
         b'homas Dillig</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-'
         b'2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15316-2">Loca'
         b'tion:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15316'
         b'-2">MPEB 6.12</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-'
         b'3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15316-3">Titl'
         b'e:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15316-3"'
         b'>Automated Error Diagnosis Using Abductive Inference</td>\n\t\t'
         b'\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<'
         b'th class="td-0" scope="row" id="row15316-4">Abstract:</th>\n\t'
         b'\t\t\t\t\t\t<td class="td-last td-1" headers="row15316-4"> When pr'
         b'ogram veri&amp;#64257;cation tools fail to verify a program, either '
         b'the program is buggy or the report is a false alarm. In this situati'
         b'on, the burden is on the user to manually classify the report, but t'
         b'his task is time-consuming, error-prone, and does not utilize facts '
         b'already proven by the analysis. We present a new technique for assis'
         b'ting users in classifying error reports. Our technique computes smal'
         b'l, relevant queries presented to a user that capture exactly the inf'
         b'ormation the analysis is missing to either discharge or validate the'
         b' error. Our insight is that identifying these missing facts is an in'
         b'stance of the abductive inference problem in logic, and we present a'
         b' new algorithm for computing the smallest and most general abduction'
         b's in this setting. We perform the &amp;#64257;rst user study to rigo'
         b'rously evaluate the accuracy and effort involved in manual classi&am'
         b'p;#64257;cation of error reports. Our study demonstrates that our ne'
         b'w technique is very useful for improving both the speed and accuracy'
         b' of error report classification.</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<t'
         b'r class="tr-odd tr-5">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" i'
         b'd="row15316-5"> </th>\n\t\t\t\t\t\t\t<td class="td-last td-1" header'
         b's="row15316-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even'
         b' tr-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15316-'
         b'6"> </th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15316-'
         b'6"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-d'
         b'efault"><div class="divider"><hr /></div></div><div id="c15535" clas'
         b's="csc-default">\n\t\t\t\t<table class="contenttable contenttable'
         b'-0">\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class'
         b'="td-0" scope="row" id="row15535-0">Time / date:</th>\n\t\t\t\t\t\t'
         b'\t<td class="td-last td-1" headers="row15535-0">Monday 4th Februa'
         b'ry 2013</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1"'
         b'>\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15535-1">Speake'
         b'r:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15535-1"'
         b'>Mooly Sagiv</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-'
         b'2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15535-2">Loca'
         b'tion:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15535'
         b'-2">MPEB 6.12</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-'
         b'3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15535-3">Titl'
         b'e:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15535-3"'
         b'>Concurrent Data Representation Synthesis</td>\n\t\t\t\t\t</tr'
         b'>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="t'
         b'd-0" scope="row" id="row15535-4">Abstract:</th>\n\t\t\t\t\t\t\t<td c'
         b'lass="td-last td-1" headers="row15535-4"> We describe an approach fo'
         b'r synthesizing data representations for concurrent programs. Our com'
         b'piler takes as input a program written using concurrent relations an'
         b'd synthesizes a representation of the relations as sets of cooperati'
         b'ng data structures as well as the placement and acquisition of locks'
         b' to synchronize concurrent access to those data structures. The resu'
         b'lting code is correct by construction: individual relational operati'
         b'ons are implemented correctly and the aggregate set of operations is'
         b' serializable and deadlock free. The relational specification also p'
         b'ermits a high-level optimizer to choose the best performing of many '
         b'possible legal data representations and locking strategies, which we'
         b' demonstrate with an experiment autotuning a graph benchmark.&lt;p&g'
         b't;This is joint work with Alex Aiken and Peter Hawkins(Stanford), Ka'
         b'tleen Fisher(DARPA), and Martin Rinard(MIT). This work is part of Pe'
         b'trer Hawkins thesis http://theory.stanford.edu/~hawkinsp/ Please als'
         b'o look into the  December CACM article.</td>\n\t\t\t\t\t</tr>\n'
         b'\t\t\t\t\t<tr class="tr-odd tr-5">\n\t\t\t\t\t\t\t<th class="td-0'
         b'" scope="row" id="row15535-5"> </th>\n\t\t\t\t\t\t\t<td class="td-la'
         b'st td-1" headers="row15535-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr'
         b' class="tr-even tr-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="row'
         b'" id="row15535-6"> </th>\n\t\t\t\t\t\t\t<td class="td-last td-1" hea'
         b'ders="row15535-6"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><d'
         b'iv id="c15534" class="csc-default">\n\t\t\t\t<table class="conten'
         b'ttable contenttable-0">\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t'
         b'\t\t\t\t\t\t<th class="td-0" scope="row" id="row15534-0">Time / da'
         b'te:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15534-0'
         b'">Friday 1st February 2013, 4pm-5pm</td>\n\t\t\t\t\t</tr>\n\t\t\t\t'
         b'\t<tr class="tr-odd tr-1">\n\t\t\t\t\t\t\t<th class="td-0" scope='
         b'"row" id="row15534-1">Speaker:</th>\n\t\t\t\t\t\t\t<td class="td-las'
         b't td-1" headers="row15534-1">Mooly Savig</td>\n\t\t\t\t\t</tr>'
         b'\n\t\t\t\t\t<tr class="tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row15534-2">Location:</th>\n\t\t\t\t\t\t\t<td cl'
         b'ass="td-last td-1" headers="row15534-2">103 &amp; 104 Executive Suit'
         b'e</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15534-3">Title:</'
         b'th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15534-3">Eff'
         b'ectively-Propositional Reasoning About Reachabilitysis</td>\n'
         b'\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t'
         b'\t<th class="td-0" scope="row" id="row15534-4">Abstract:</th>'
         b'\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15534-4"> This '
         b'paper proposes a novel method of harnessing existing SAT solvers to '
         b'verify reachability properties of programs that manipulate linked-li'
         b'st data structures. Such properties are essential for proving progra'
         b'm termination, correctness of data structure invariants, and other s'
         b'afety properties. Our solution is complete, i.e., a SAT solver produ'
         b'ces a counterexample whenever a program does not satisfy its specifi'
         b'cation. This result is surprising since even first-order theorem pro'
         b'vers usually cannot deal with reachability in a complete way, becaus'
         b'e doing so requires reasoning about transitive closure. Our result i'
         b's based on the following ideas: 1.  Programmers must write assertion'
         b's in a restricted logic without quantifier alternation or function s'
         b'ymbols. 2.  The correctness of many programs can be expressed in suc'
         b'h restricted logics, although we explain the tradeoffs. 3.  Recent r'
         b'esults in descriptive complexity can be utilized to show that every '
         b'program that manipulates potentially cyclic, singly- and doubly-link'
         b'ed lists and that is annotated with assertions written in this restr'
         b'icted logic, can be verified with a SAT solver. We implemented a too'
         b'l atop Z3 and used it to show the correctness of several linked list'
         b' programs.  This work is part of Peter Hawkins thesis http://theory.'
         b'stanford.edu/~hawkinsp/ Please also look into the  December CACM art'
         b'icle.</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-5">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15534-5"> </t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15534-5"> </t'
         b'd>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-last">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15534-6"> </t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15534-6"> </t'
         b'd>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"'
         b'><div class="divider"><hr /></div></div><div id="c15533" class="csc-'
         b'default">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t\t'
         b'\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" sco'
         b'pe="row" id="row15533-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class='
         b'"td-last td-1" headers="row15533-0">Friday 30th November 2012</t'
         b'd>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t'
         b'\t\t\t<th class="td-0" scope="row" id="row15533-1">Speaker:</th'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15533-1">Dan G'
         b'hica</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15533-2">Location'
         b':</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15533-2">'
         b'MPEB 6.12</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-'
         b'3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15533-3">Titl'
         b'e:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row15533-3"'
         b'>Seamless Computing</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-e'
         b'ven tr-4">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row15533-'
         b'4">Abstract:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="r'
         b'ow15533-4"> Computer architectures are evolving and diversifying: CP'
         b'U-based, GPU-based, distributed, reconfigurable, cloud-based and so '
         b'on. Along with them we are faced with a proliferation of domain-spec'
         b'ific architecture-dependent languages, leading to an environment in '
         b'which programming is laborious and error-prone. In this talk I will '
         b'outline an ongoing research project dedicated to the study of archit'
         b'ecture-independent programming, from theoretical foundations (semant'
         b'ics and types) to compiler support.</td>\n\t\t\t\t\t</tr>\n\t\t\t\t'
         b'\t<tr class="tr-odd tr-last">\n\t\t\t\t\t\t\t<th class="td-0" sco'
         b'pe="row" id="row15533-5"> </th>\n\t\t\t\t\t\t\t<td class="td-last td'
         b'-1" headers="row15533-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table><'
         b'/div><div class="csc-default"><div class="divider"><hr /></div></div'
         b'><div id="c14602" class="csc-default">\n\t\t\t\t<table class="con'
         b'tenttable contenttable-0">\n\t\t\t\t\t<tr class="tr-even tr-0"'
         b'>\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row14602-0">Time /'
         b' date:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row1460'
         b'2-0">Fri 14th Sept 2012, 4-5pm</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr '
         b'class="tr-odd tr-1">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id='
         b'"row14602-1">Speaker:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" h'
         b'eaders="row14602-1">Fabrizio Montesi</td>\n\t\t\t\t\t</tr>\n\t\t\t'
         b'\t\t<tr class="tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td-0" scop'
         b'e="row" id="row14602-2">Location:</th>\n\t\t\t\t\t\t\t<td class="td-'
         b'last td-1" headers="row14602-2">Cruciform Foyer 101 Seminar Room 1</'
         b'td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t\t\t'
         b'\t\t\t\t<th class="td-0" scope="row" id="row14602-3">Title:</th>'
         b'\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row14602-3">Deadlo'
         b'ck-freedom-by-design: Multiparty Asynchronous Global Programming</td'
         b'>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t'
         b'\t\t\t<th class="td-0" scope="row" id="row14602-4">Abstract:</t'
         b'h>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row14602-4"> Cho'
         b'r (http://www.chor-lang.org/) is a new programming language for comm'
         b'unicating systems based, where both behavioural protocol specificati'
         b'ons and implementations (choreographies) are given at a global level'
         b'. Then, the code for each concrete endpoint entity of a system can b'
         b'e automatically generated, with the guarantees of soundness and comp'
         b'leteness wrt the originating descriptions. Interestingly, by exploit'
         b'ing global descriptions, Chor defines a new class of asynchronous de'
         b'adlock-free systems which eludes standard practices in object-orient'
         b'ed and session-based type systems. In this talk, I will give an over'
         b'view of the formal model behind Chor and I will demonstrate its prot'
         b'otype implementation, an IDE and compiler that allow for the first t'
         b'ime to experiment with the global programming paradigm. The target i'
         b'mplementation language of the Chor compiler is Jolie (http://www.jol'
         b'ie-lang.org/), enabling the generated code to interoperate with a va'
         b'riety of environments.</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="t'
         b'r-odd tr-last">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row1'
         b'4602-5"> </th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row1'
         b'4602-5"> </td>\n\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="'
         b'csc-default"><div class="divider"><hr /></div></div><div id="c14657"'
         b' class="csc-default">\n\t\t\t\t<table cellspacing="2" cellpadding'
         b'="2" class="contenttable contenttable-0">\n\t\t\t\t\t<tfoot>\n\t'
         b'\t\t\t\t<tr class="tr-odd tr-last">\n\t\t\t\t\t\t\t<th class="td-0" '
         b'scope="row" id="row14657-5"> </th>\n\t\t\t\t\t\t\t<td class="td-last'
         b' td-1" headers="row14657-5"> </td>\n\t\t\t\t\t</tr></tfoot><tbody>'
         b'\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row14657-0">Time / date:</th>\n\t\t\t\t\t\t\t<td'
         b' class="td-last td-1" headers="row14657-0">Wed 12th Sept 2012, 12-1p'
         b'm</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n'
         b'\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row14657-1">Speaker:'
         b'</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row14657-1">T'
         b'homas Stroeder</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even t'
         b'r-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row14657-2">Lo'
         b'cation:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row146'
         b'57-2">Malet Place Eng 1.20</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr clas'
         b's="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row'
         b'14657-3">Title:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers'
         b'="row14657-3">Automated Termination Analysis of Imperative Programs '
         b'with Pointer Arithmetic and Heap Manipulations</td>\n\t\t\t\t\t</t'
         b'r>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="'
         b'td-0" scope="row" id="row14657-4">Abstract:</th>\n\t\t\t\t\t\t\t<td '
         b'class="td-last td-1" headers="row14657-4">Automated termination anal'
         b'ysis of imperative programs has been studied very intensively during'
         b' the last decade and powerful tools performing this task have been d'
         b'eveloped. While some of these tools can already successfully analyze'
         b' programs involving heap manipulations, the combination of pointer a'
         b'rithmetic and heap manipulations is still an open problem. Such comb'
         b'inations are especially used in C functions for string processing wh'
         b'ere a string is traversed using pointer arithmetic until a zero valu'
         b'e is found on the heap. We will show a novel method for automated te'
         b'rmination analysis of imperative programs based on the Low-Level Vir'
         b'tual Machine (LLVM) framework, symbolic evaluation graphs, and term '
         b'rewriting. We will demonstrate its capabilities on the example of a '
         b'standard C implementation of the strlen function called on zero-term'
         b'inated strings and give an overview over preliminary experimental re'
         b'sults with a prototype implementation on a small benchmark set of pr'
         b'ograms.</td>\n\t\t\t\t\t</tr></tbody>\n\t\t\t\t</table></div><div c'
         b'lass="csc-default"><div class="divider"><hr /></div></div><div id="c'
         b'14857" class="csc-default">\n\t\t\t\t<table class="contenttable c'
         b'ontenttable-0">\n\t\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t'
         b'\t\t<th class="td-0" scope="row" id="row14857-0">Time / date:</th>'
         b'\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row14857-0"> Fri 7'
         b' Sept 2012, 11am-12pm</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr'
         b'-odd tr-1">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row14857'
         b'-1">Speaker:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="r'
         b'ow14857-1">Marc Brockschmidt</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr cl'
         b'ass="tr-even tr-2">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="'
         b'row14857-2">Location:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" h'
         b'eaders="row14857-2">Cruciform Foyer 201 Seminar Room 3</td>\n'
         b'\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t'
         b'<th class="td-0" scope="row" id="row14857-3">Title:</th>\n\t\t\t'
         b'\t\t\t\t<td class="td-last td-1" headers="row14857-3">Proving Java T'
         b'ermination: Reducing the Ugly to the Bad</td>\n\t\t\t\t\t</tr>'
         b'\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t\t\t\t\t\t<th class="td'
         b'-0" scope="row" id="row14857-4">Abstract:</th>\n\t\t\t\t\t\t\t<td cl'
         b'ass="td-last td-1" headers="row14857-4">We present symbolic evaluati'
         b'on graphs for Java programs, obtained by symbolicevaluation and abst'
         b'raction on a simple abstract domain. As over-approximations of all p'
         b'ossible program runs, these graphs then serve as basis for further a'
         b'nalyses. We present one possible use, termination analysis, for whic'
         b'h the graph is transformed into Term Rewrite Systems (TRSs) whose te'
         b'rmination implies termination of the original program. For analysis '
         b'of the resulting TRSs, we can then use existing standard tools.</td>'
         b'\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-last">\n\t\t\t'
         b'\t\t\t\t<th class="td-0" scope="row" id="row14857-5"> </th>\n'
         b'\t\t\t\t\t\t\t<td class="td-last td-1" headers="row14857-5"> </td>\n'
         b'\t\t\t\t\t</tr>\n\t\t\t\t</table></div><div class="csc-default"><d'
         b'iv class="divider"><hr /></div></div><div id="c14821" class="csc-def'
         b'ault">\n\t\t\t\t<table class="contenttable contenttable-0">\n\t'
         b'\t\t\t\t<tr class="tr-even tr-0">\n\t\t\t\t\t\t\t<th class="td-0" sc'
         b'ope="row" id="row14821-0">Time / date:</th>\n\t\t\t\t\t\t\t<td class'
         b'="td-last td-1" headers="row14821-0">Fri 31st Aug 2012, 4-5pm</t'
         b'd>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-odd tr-1">\n\t\t\t\t'
         b'\t\t\t<th class="td-0" scope="row" id="row14821-1">Speaker:</th'
         b'>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row14821-1">Delph'
         b'ine Demange</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-2'
         b'">\n\t\t\t\t\t\t\t<th class="td-0" scope="row" id="row14821-2">Locat'
         b'ion:</th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row14821-'
         b'2">Cruciform Foyer 101 Seminar Room 1</td>\n\t\t\t\t\t</tr>\n\t\t'
         b'\t\t\t<tr class="tr-odd tr-3">\n\t\t\t\t\t\t\t<th class="td-0" scop'
         b'e="row" id="row14821-3">Title:</th>\n\t\t\t\t\t\t\t<td class="td-las'
         b't td-1" headers="row14821-3">Plan B - A Buffered Memory Model for Ja'
         b'va</td>\n\t\t\t\t\t</tr>\n\t\t\t\t\t<tr class="tr-even tr-4">\n\t\t'
         b'\t\t\t\t\t<th class="td-0" scope="row" id="row14821-4">Abstract:<'
         b'/th>\n\t\t\t\t\t\t\t<td class="td-last td-1" headers="row14821-4">Th'
         b'e Java Memory Model (JMM) is an ambitious attempt to provide a seman'
         b'tics for concurrent and possibly racy Java programs. It aims at prov'
         b'iding a precise semantics that is portable across all architectures '
         b'and enables a variety of compiler optimizations. Unfortunately, the '
         b'JMM has proven to be challenging for users to understand and for com'
         b'piler writers to use. In fact, the formal statement of the model is '
         b'flawed and existing Java compilers do not comply with it. We propose'
         b' to investigate an alternative proposal that has a tractable definit'
         b'ion and intuitive semantics, relates easily to existing architecture'
         b's, while still enabling useful optimizations. To this end, we introd'
         b'uce a Buffered Memory Model for Java. Beyond its simplicity advantag'
         b'es for the programmer, the model is also amenable for formal reasoni'
         b'ng and verification. We also demonstrate that it can be implemented '
         b'efficiently on x86-TSO architectures.(joint work with V. Laporte, L.'
         b' Zhao, D. Pichardie, S. Jagannathan and J. Vitek)</td>\n\t\t\t\t\t'
         b'</tr>\n\t\t\t\t\t<tr class="tr-odd tr-last">\n\t\t\t\t\t\t\t<th cl'
         b'ass="td-0" scope="row" id="row14821-5"> </th>\n\t\t\t\t\t\t\t<td cla'
         b'ss="td-last td-1" headers="row14821-5"> </td>\n\t\t\t\t\t</tr>'
         b'\n\t\t\t\t</table></div>\r\n<!--TYPO3SEARCH_end-->\r\n\r\n\r\n </'
         b'div> \r\n\r\n<div id="responsible">\r\n  <div class="tx-responsibl'
         b'e-pi1">This page was last modified on 30 Mar 2017.</div>\r\n</div>'
         b'\r\n      \r\n </div> \r\n   \r\n    </div> \r\n    <div id="right'
         b'content" class="container"> \r\n     \r\n\r\n    \r\n  </div> \r\n'
         b'  </div> \r\n\r\n  <div id="footer"> \r\n  <!-- page_footer slot -'
         b'-> \r\n  <div id="hr"> \r\n    <hr class="no" /> \r\n  </div> \r\n  '
         b'<p class="contact">Department of Computer Science - University Colle'
         b'ge London - Gower Street - London - WC1E\r\n    6BT - <img src="fi'
         b'leadmin/pplv/templates/images/phone.gif" width="13" height="9" id="p'
         b'hone" alt="Telephone:" /> +44 (0)20 7679 7214 - Copyright &copy; 199'
         b'9-2017 UCL</p> \r\n  <div id="inlinelist">\r\n      <ul>\r\n      '
         b'  <li><a href="http://www.ucl.ac.uk/disclaimer/" title="Disclaimer">'
         b'Disclaimer</a> |  </li>\r\n        <li><a href="http://www.ucl.ac.'
         b'uk/accessibility/" title="Accessibility">Accessibility</a> | </l'
         b'i>\r\n\r\n        <li><a href="http://www.ucl.ac.uk/priv/" title="Pr'
         b'ivacy">Privacy</a> | </li>\r\n        <li><a href="http://www.ucl.'
         b'ac.uk/advanced-search/" title="UCL Search">UCL Search</a> | </li'
         b'>\r\n        <li><a href="http://www.cs.ucl.ac.uk/help.html" title'
         b'="UCL-CS Help">UCL-CS Help</a></li>\r\n      </ul>\r\n  </div>\r\n'
         b'    <br /> \r\n</div>\n\n\n\n\n</body>\n</html>',
 'links': [1202,
           22,
           1182,
           1203,
           1204,
           1205,
           1206,
           1208,
           1282,
           1283,
           1284,
           1212,
           1209],
 'pid': 1207,
 'url': 'http://pplv.cs.ucl.ac.uk/research_seminars/'}